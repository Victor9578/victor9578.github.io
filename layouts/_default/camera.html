<!DOCTYPE html>
<html lang="{{ .Site.LanguageCode | default " en" }}">

<head>
  <!-- 引入主题头部 (PaperMod 的 CSS 变量都在这里面) -->
  {{ partial "head.html" . }}
  <style>
    /* ================== 0. 核心变量适配 (修复暗黑模式) ================== */
    /* 
       PaperMod 使用 CSS 变量：
       --theme: 背景色
       --entry: 卡片背景色
       --primary: 主要文字色
       --nav-width: 导航栏宽度
       --gap: 间距
    */
    /* 定义我们自己需要的变量，默认跟随主题变量 */
    :root {
      --gallery-gap: 4px;
      --gallery-header-bg: rgba(255, 255, 255, 0.95);
      /* 浅色模式吸顶条 */
      --gallery-border: rgba(0, 0, 0, 0.05);
    }

    /* ★★★ 关键：当 body 有 dark 类时（PaperMod 暗黑模式激活） ★★★ */
    body.dark {
      --gallery-header-bg: rgba(29, 30, 32, 0.95);
      /* 深色模式吸顶条 (PaperMod 深灰) */
      --gallery-border: rgba(255, 255, 255, 0.1);
    }

    /* ================== 1. 基础布局 ================== */
    body {
      overflow-x: hidden;
      /* 使用主题变量，这样切换按钮一按，背景自动变 */
      background-color: var(--theme) !important;
      color: var(--primary) !important;
      padding-bottom: 50px;
    }

    /* 修复宽度问题：恢复你之前的计算公式 */
    #gallery-root {
      margin: 0 auto;
      padding: 0;
      /* 既然计算公式里含了 gap，这里 padding 可以去掉或微调 */
      width: 100%;
      /* 你的自定义宽度公式 */
      max-width: calc(var(--nav-width) + var(--gap) * 2);
    }

    /* ================== 2. 月份分组 ================== */
    .month-section {
      margin-bottom: 20px;
      animation: fadeIn 0.5s ease-in;
    }

    .month-header {
      font-size: 1.5rem;
      font-weight: 400;
      color: var(--primary);
      /* 跟随主题文字色 */
      padding: 24px 8px 16px;
      position: sticky;
      top: 0;
      /* 使用我们上面适配好的背景变量 */
      background-color: var(--gallery-header-bg);
      backdrop-filter: blur(10px);
      z-index: 90;
      border-bottom: 1px solid var(--gallery-border);
      transition: background-color 0.3s;
    }

    /* ================== 3. 图片网格 ================== */
    .photo-grid {
      display: flex;
      flex-wrap: wrap;
      /* 使用负 margin 抵消间距 */
      margin: calc(var(--gallery-gap) * -1);
    }

    .photo-grid::after {
      content: '';
      flex-grow: 999999999;
    }

    .photo-item {
      margin: var(--gallery-gap);
      position: relative;
      /* 使用主题的 entry 变量 (卡片背景色)，暗黑模式下会自动变深灰 */
      background-color: var(--entry);
      overflow: hidden;
      cursor: zoom-in;
      border-radius: 4px;
      /* 稍微弱化阴影，PaperMod 风格比较扁平 */
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      transition: transform 0.2s, box-shadow 0.2s;
    }

    .photo-item:hover {
      transform: translateY(-2px);
      z-index: 2;
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.2);
    }

    .photo-placeholder {
      height: 0;
      width: 100%;
    }

    .photo-item img {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      opacity: 0;
      transition: opacity 0.4s ease-out;
    }

    .photo-item img.loaded {
      opacity: 1;
    }

    /* ================== 4. 加载与哨兵 ================== */
    #load-sentinel {
      text-align: center;
      padding: 40px;
      color: var(--secondary);
      /* 使用主题次级文字色 */
      font-size: 14px;
    }

    .spinner {
      display: inline-block;
      width: 24px;
      height: 24px;
      border: 3px solid rgba(128, 128, 128, 0.2);
      border-radius: 50%;
      border-top-color: var(--primary);
      animation: spin 1s ease-in-out infinite;
      margin-bottom: 8px;
    }

    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(10px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    /* ================== 5. Lightbox ================== */
    #image-viewer {
      display: none;
      position: fixed;
      z-index: 9999;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.95);
      backdrop-filter: blur(5px);
      flex-direction: column;
      justify-content: center;
      align-items: center;
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    #image-viewer.active {
      display: flex;
      opacity: 1;
    }

    /* 预览工具栏定位 */
    .viewer-toolbar {
      position: absolute;
      top: 20px;
      right: 20px;
      z-index: 1001;
      display: flex;
      gap: 20px;
      /* 按钮之间的间距 */
    }

    /* 按钮通用样式 */
    #viewer-close,
    #viewer-fullscreen {
      color: #fff;
      font-size: 35px;
      font-weight: bold;
      cursor: pointer;
      user-select: none;
      transition: opacity 0.2s;
      line-height: 1;
    }

    #viewer-close:hover,
    #viewer-fullscreen:hover {
      opacity: 0.7;
    }

    /* 全屏图标调整大小 */
    #viewer-fullscreen {
      font-size: 30px;
      margin-top: 2px;
    }

    #full-image {
      max-width: 95%;
      max-height: 95%;
      object-fit: contain;
      box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
    }

    /* 原来的 viewer-close 定位现在由 viewer-toolbar 控制，这里可以移除或简化 */
    /* #viewer-close {
        position: absolute;
        top: 30px;
        right: 40px;
        color: #fff;
        font-size: 40px;
        font-weight: bold;
        cursor: pointer;
    } */
    #viewer-loading {
      position: absolute;
      color: #fff;
    }

    @media (max-width: 600px) {
      .month-header {
        font-size: 1.4rem;
        padding: 15px 5px;
      }

      .photo-item {
        margin: 2px;
      }

      .photo-grid {
        margin: -2px;
      }

      .viewer-toolbar {
        top: 10px;
        right: 10px;
        gap: 15px;
      }
    }
  </style>
</head>
<!-- 给 body 加 id="top"，让回顶按钮生效 -->

<body class="list" id="top">
  <!-- 导航栏 -->
  {{ partial "header.html" . }}
  <!-- 主内容区 -->
  <main style="width: 100%; max-width: 100%; padding: 0; min-height: 80vh;">
    <div id="gallery-root"></div>
    <div id="load-sentinel">
      <div class="spinner" id="loading-spinner"></div>
      <div id="loading-text">正在连接云端相册...</div>
    </div>
  </main>
  <!-- Lightbox (修改了结构) -->
  <div id="image-viewer">
    <div class="viewer-toolbar">
      <span id="viewer-fullscreen" title="全屏模式">⛶</span>
      <span id="viewer-close">&times;</span>
    </div>
    <div id="viewer-loading" class="spinner" style="border-top-color: #fff;"></div>
    <img id="full-image">
  </div>
  <!-- 页脚 (PaperMod 的回到顶部按钮 top-link 在这里) -->
  {{ partial "footer.html" . }}
  <!-- JS 逻辑 (修改了逻辑) -->
  <script>
    document.addEventListener("DOMContentLoaded", function () {
      // ================= 配置区域 =================
      const config = {
        // ★ 注意：去掉末尾的斜杠 /，防止拼接成 //api/fs/list
        host: "https://la.581019.xyz/alist",
        path: "/Camera",
        baseHeight: 220,
        targethdThumbSize: 600,  // 列表视图分辨率
        targetudThumbSize: 1600, // 大图预览分辨率
        pageSize: 30
      };
      let currentPage = 1;
      let isLoading = false;
      let hasMore = true;
      const galleryRoot = document.getElementById('gallery-root');
      const sentinel = document.getElementById('load-sentinel');
      const loadingText = document.getElementById('loading-text');
      const spinner = document.getElementById('loading-spinner');

      // 预览相关的 DOM
      const viewer = document.getElementById('image-viewer');
      const fullImage = document.getElementById('full-image');
      const viewerLoading = document.getElementById('viewer-loading');
      const viewerClose = document.getElementById('viewer-close');
      // ★ 新增：全屏按钮
      const viewerFullscreen = document.getElementById('viewer-fullscreen');

      const monthGridCache = new Map();

      function getDateLabel(isoDateString) {
        if (!isoDateString) return "未知日期";
        const date = new Date(isoDateString);
        return `${date.getFullYear()}/${date.getMonth() + 1}`;
      }
      function getMonthGrid(dateLabel) {
        if (monthGridCache.has(dateLabel)) return monthGridCache.get(dateLabel);
        const id = 'month-' + dateLabel.replace(/[\s年月]/g, '-');
        let section = document.getElementById(id);
        if (!section) {
          section = document.createElement('div');
          section.className = 'month-section';
          section.id = id;
          section.innerHTML = `<div class="month-header">${dateLabel}</div><div class="photo-grid"></div>`;
          galleryRoot.appendChild(section);
        }
        const grid = section.querySelector('.photo-grid');
        monthGridCache.set(dateLabel, grid);
        return grid;
      }

      async function processAndRenderImage(file) {
        // 1. 初始化变量 (默认用原版缩略图)
        let hdThumbUrl = file.thumb;
        let udThumbUrl = file.thumb;
        // 2. 如果是微软链接，则进行高清替换
        if (file.thumb && file.thumb.includes('width=') && file.thumb.includes('height=')) {
          hdThumbUrl = file.thumb.replace(/width=\d+/, `width=${config.targethdThumbSize}`)
            .replace(/height=\d+/, `height=${config.targethdThumbSize}`);
          udThumbUrl = file.thumb.replace(/width=\d+/, `width=${config.targetudThumbSize}`)
            .replace(/height=\d+/, `height=${config.targetudThumbSize}`);
        }
        // 3. 获取尺寸
        let dims = { width: 400, height: 300 };
        try {
          dims = await new Promise((resolve) => {
            const img = new Image();
            img.src = file.thumb; // 用原版小图测算，速度快
            img.onload = () => resolve({ width: img.naturalWidth, height: img.naturalHeight });
            img.onerror = () => resolve({ width: 400, height: 300 });
          });
        } catch (e) { }
        // 4. 渲染
        const dateLabel = getDateLabel(file.modified);
        const grid = getMonthGrid(dateLabel);
        const flexWidth = dims.width * config.baseHeight / dims.height;
        const paddingBottom = (dims.height / dims.width) * 100;
        const itemDiv = document.createElement('div');
        itemDiv.className = 'photo-item';
        itemDiv.style.width = `${flexWidth}px`;
        itemDiv.style.flexGrow = flexWidth;
        itemDiv.innerHTML = `
          <div class="photo-placeholder" style="padding-bottom: ${paddingBottom}%;"></div>
          <img src="${hdThumbUrl}"
            loading="lazy"
            alt="${file.name}"
            onload="this.classList.add('loaded')"
            onerror="this.style.display='none'">
        `;
        itemDiv.onclick = () => openLightbox(udThumbUrl);
        grid.appendChild(itemDiv);
      }
      async function loadNextPage() {
        if (isLoading || !hasMore) return;
        isLoading = true;
        const requestData = {
          path: config.path,
          password: "",
          page: currentPage,
          per_page: config.pageSize,
          refresh: false
        };
        try {
          const response = await fetch(config.host + "/api/fs/list", {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(requestData)
          });
          // ★ 错误捕捉：如果 Worker 还是返回 HTML，这里会报错
          const contentType = response.headers.get("content-type");
          if (contentType && contentType.indexOf("application/json") === -1) {
            throw new Error("服务器返回了非 JSON 数据，可能是 Alist 页面 HTML。请检查 Worker 配置。");
          }
          const result = await response.json();
          if (result.code === 200 && result.data.content) {
            const files = result.data.content;
            if (files.length < config.pageSize) {
              hasMore = false;
              spinner.style.display = 'none';
              loadingText.innerText = "—— 到底了 ——";
              loadingText.style.marginTop = "20px";
            }
            const images = files.filter(file => file.type !== 1 && file.thumb);
            if (images.length > 0) {
              images.sort((a, b) => new Date(b.modified) - new Date(a.modified));
              await Promise.all(images.map(file => processAndRenderImage(file)));
              currentPage++;
            } else {
              if (hasMore) {
                currentPage++;
                setTimeout(() => { isLoading = false; loadNextPage(); }, 10);
                return;
              }
            }
          } else {
            hasMore = false;
            spinner.style.display = 'none';
            loadingText.innerText = "加载完毕";
          }
        } catch (e) {
          console.error(e);
          loadingText.innerText = "网络请求失败: " + e.message;
        } finally {
          isLoading = false;
        }
      }

      // ================= Lightbox 逻辑 (包含全屏) =================

      function openLightbox(url) {
        viewer.classList.add('active');
        fullImage.style.display = 'none';
        viewerLoading.style.display = 'block';
        document.body.style.overflow = 'hidden';
        fullImage.src = url;
        fullImage.onload = () => {
          viewerLoading.style.display = 'none';
          fullImage.style.display = 'block';
        };
      }

      function closeLightbox() {
        // 如果当前是全屏状态，先退出全屏
        if (document.fullscreenElement) {
          document.exitFullscreen().catch(e => console.log(e));
        }
        viewer.classList.remove('active');
        fullImage.src = '';
        document.body.style.overflow = 'auto';
      }

      // ★ 新增：全屏切换函数
      function toggleFullScreen() {
        if (!document.fullscreenElement) {
          // 请求 viewer 容器全屏
          viewer.requestFullscreen().catch(err => {
            alert(`无法启用全屏: ${err.message}`);
          });
        } else {
          document.exitFullscreen();
        }
      }

      // 绑定事件
      viewerClose.onclick = closeLightbox;

      // ★ 绑定全屏按钮点击
      if (viewerFullscreen) {
        viewerFullscreen.onclick = (e) => {
          e.stopPropagation(); // 防止冒泡关闭 viewer
          toggleFullScreen();
        };
      }

      // 点击背景关闭
      viewer.onclick = (e) => {
        // 确保只点击 viewer 本身而不是内部的图片或工具栏才关闭
        if (e.target === viewer || e.target === fullImage) closeLightbox();
      };

      // 按 ESC 键关闭 (浏览器自带 ESC 退出全屏，但我们需要确保在非全屏状态下也能关闭 Lightbox)
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && viewer.classList.contains('active')) {
          // 如果是全屏状态，ESC 会自动退出全屏，这里保证退出后 Lightbox 也关闭
          if (!document.fullscreenElement) {
            closeLightbox();
          }
        }
      });

      const observer = new IntersectionObserver((entries) => {
        if (entries[0].isIntersecting) loadNextPage();
      }, { root: null, rootMargin: '200px', threshold: 0.1 });
      observer.observe(sentinel);
    });
  </script>
</body>

</html>