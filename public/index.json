[{"content":"我的博客又要开始了 今后我会在vscode 来写markdown来更新我的blog 希望可以帮助到各位！！！😁\n","permalink":"https://www.jaywxl.eu.org/posts/life/1_first-post/","summary":"Say Hello!🤩","title":"First Post"},{"content":"影视收藏 😜🤥\n不定期更新\n所有站点都来源于互联网\n低端影视\r哔嘀影视\r真不卡 片库\r独播库\r奈飞中文电影站\r泥巴影院\rTubitv\r剧嗨\r一些种子站点\n--by Jaywxl\n","permalink":"https://www.jaywxl.eu.org/posts/life/2_secend/","summary":"搜刮的一些在线视频站点。","title":"影视收藏"},{"content":" 在这里\n向长安，对秋灯，几人老？\n这是一抔喧哗了千年的黄土，是十三朝顶礼膜拜的故都。这里秦时的明月正皎洁，汉代的城门正轻启。\n秦始皇在这里挥剑浮云，东指六国，逐鹿中原；汉武帝在这里横剑漠北，踏碎匈奴铁骑的狼烟；张骞在这里拜别故里，逶迤西行，踩出丝绸之路曲折的痕迹；玄奘在这里打点行装，把大唐盛世的种子播撒向繁花如锦的天竺。无数人怀揣着无数瑰丽的梦，把鲜活的生命化作丹砂，镌刻在汗青竹简里。这里，万世流芳。\n骊山的草木见证着，周幽烽火在这里戏取各路诸侯，褒姒倾国倾城的微笑揭开春秋乱世的序幕；大明宫殿前的麒麟目睹了，牡丹在这里不畏武皇淫威的铁骨铮铮，翩跹至洛阳而名动天下；华清池的海棠汤倒映过，杨贵妃在这里霓裳羽衣轻柔的魅影，断送一代盛世璀璨的华章；摆着酒座亭台楼阁回忆着，诗仙李白把酒当歌，绣口吐出半个盛唐的飘逸与洒脱。这是历史最绚丽的舞台，动人的故事演绎出一幕幕惊心动魄的诗行。这里，百转千回。\n响彻高原的秦腔伴着埙声叙述着悠远的传说，羊肉泡馍的暖汤融化了柿子上凝结的火红的秋霜。摇着蒲扇的老人，敲着波浪鼓的孩子，细嗅沿街槐花飘香十里，踏过梧桐橙黄橘绿的落叶缤纷；踩着高跟鞋的白领丽人，捂着耳机灌输摇滚的学生，穿过滚滚而过的车烟肆虐，抬眼望摩天大楼里映出的云淡风轻。精彩的生活，融入一个个或悠闲或匆忙的背影，传递着生命的脉搏，为世界注入鲜活的血液。这里，异彩纷呈。\n只有在这里，历史与现代才能如此完美地融合。如同古老的雁塔金铃声中飞扬的喷泉音乐，如同晨钟暮鼓的低吟浅唱里车流的喧嚣不息。\n这里，是时间的灰烬，是历史的尘埃，沐浴着新时代的甘露，绽放出一朵崭新的明媚的芬芳。\n这里，长安。\n","permalink":"https://www.jaywxl.eu.org/posts/life/9_long_ago_compostion/","summary":"一篇小学时看的满分作文，时乃至今，仍觉得惊为天人！\u003cbr\u003e向长安，对秋灯，几人老","title":"Notes | 一篇满分作文 --《在这里》"},{"content":"缘起 第一次来汉中是在22年的八月份，那年夏天很热。炎炎的烈日烤干了我最后的暑期，滚烫的热浪就迫不及待地卷着我走入这纷杂的社会。\n刚进单位，在西安办完所有的手续，直接到汉中入职。 第一份工作主要是做传统的地质工作，搞搞边坡、削削坡、种种树，日子过得也算是快活。\n梦魇的到来，事情比心里的预期更加让人难以接受——干地质调查，每天从大山深处抡着双腿，用双脚丈量祖国大地。\n抚摸着葱葱郁郁的重峦叠嶂，聆听着清澈见底的曲水延绵。这是办公室同志们梦寐以求的工作。他们总说这像旅游一样。\n20221031 105914 02\n20221101 081536 01\n20221101 100341 01\n20221102 110120 01\n20221102 135843 01\n20221103 091958 01\n20221103 092144 01\n20221103 092206 01\n20221103 092440 01\n压弯的腰仍背负着生活，破旧的街道还承受着喧嚣。这是我感慨更深的生活。汗水播撒在土地，父子牵手于街巷，这是我爱的生活，纯粹的生活。（他们总会勾起我人文摄影的欲火，我知道我是个腊鸡啦qaq-_-）\n100元人民币一层楼的住宿条件，满满当当的住着整个项目组。我辞职了，走的很决绝。\nwr 人们总是说“找好下家，再辞职”、“想清楚了，再辞职”。我不喜欢，我想不清楚，我想不清不楚。\n回忆 23年的今天，下了D字头的动车，再一次来到这里，看着熟悉的街景，仿佛一切都没变，我也没变。我还是沉默害羞的，老同事们不敢再见了。以前会一个人悄悄地走在汉江漫滩；现在也是一个人悄悄地坐着吾悦广场的星巴克。 景色不错欧，看着（应该是4号桥）景色，路的那头是南郑，记忆中，那边有很多别墅和奇哥老婆所在的龙岗中学。不知道两口的小宝宝生下来了吗？不知道峰哥儿子的吉他学的怎么样了？不知道龙哥和对象结婚了吗？不知道尚哥混出头了吗？哈哈哈\n人说工地上的人们总是情谊重的，确实，越艰辛的环境，越能凝结纯真的友谊。我喜欢，我想做一个纯粹的人。\n未知 生活：之前的吉他还学的不明不白，喜欢的up也断更了（她是去拥抱生活了我怎么办呢）。 家人：家里的老人走了，妈妈却不那么伤心，“对于一个不能进食的古稀老人，饿着、痛苦着躺了一个月了，这种结果也是一种解脱”妈妈是一个很好的人，她胆怯却不懦弱；她自我但却充满善良。她从来都是身体力行，充满力量与希望，她很纯粹，纯粹的让人总是可怜她烦的傻（要好好待家人，每年做个体检，担起责任）。 工作：领导受够了国企的掣肘，准备摆脱桎梏（我可能又要挪地方了）。 前路迷惘，一切未知；\n心怀热忱，披荆斩棘；\n永远怀着纯粹的少年心！\n","permalink":"https://www.jaywxl.eu.org/posts/life/8_bcak_here_again/","summary":"故地重游，在人生的十字路口来到汉中，心里很是开心。这个地方还留存着步入社会的第一个脚印，今天走过了了旧人旧事老地方，交织着的回忆与现况，潸然泪下，以记此文","title":"Notes | 故地重游_汉中行"},{"content":"聊一聊这段时间 前一段时间，一直在学习算法、数据库的相关知识，想着临门一脚，转型成功。 离职的这段时间，看了很多，看了很多自己，看了很多别人，浮躁，躺平，抖音\u0026hellip; 又回到了地质行业，我已经心如死灰^`^ 说点开心的吧：\n看了煤老板夺冠很开心，玩Xperia很开心，又好看的故事很开心 看到这位up很开心\n聊一聊题目的歌 这个翻唱up我很喜欢她的嗓音，温暖人心，解决了精神内耗，转行的失败，生活所谓的孤寂，人生价值的泯灭 她的歌声可以抚慰我心\n上一次的吉他学会了，就是弹唱对不上\nQAQ 前天去喝了酒，又聊到了高中的姑娘，我想起了高中的你 想起了2022初的错过\n","permalink":"https://www.jaywxl.eu.org/posts/life/7_music_baozheni/","summary":"很久没写了，暂时搁置了转行的想法，回听起这首《抱着你》，提升不会放下，路也会沿着你的脚步想你铺来","title":"Music | 抱着你"},{"content":" 关于张悬_我想你要走了\nPart1_缘起时 最近很喜欢的一位UP主，长相美丽舒适，声音温暖治愈。\n对于人生十字路口的我给予了很多的温暖与慰藉\n很高兴在这个世界、在这段时间遇上这么美丽的一位UP。\n是的，在这个无人问津的角落\n记录一下，我的荣幸与喜欢吧！🤣\nPart2_情丝绕 hahah，有没有想起琅琊榜呢，这可真是太棒了呢\n去找了张悬这首歌的 吉他谱\n顺嘴吐槽一下，我这吉他学的是真差劲，四月有余，和弦都按不明白\n最终在这个网站找到了吉他谱(GO Here)👉\rPart3_ 还没想好起什么名字\n当然是我自己的弹唱啦\n","permalink":"https://www.jaywxl.eu.org/posts/life/6_music_miaomiao/","summary":"关于张悬_我想你要走了","title":"Music | 我想你要走了"},{"content":"时光笔记_1 生活小感慨 快乐的时光总是短暂的，进入了社会的小同志才知道学校的美好时光。那无忧无虑，那轻松惬意，那青春气息。\n美好小回忆 想起的都是美好的点点滴滴，当然是和男人的，男人在一起总是快乐的，一点小事，鸡毛蒜皮，相互阴阳怪气，相互恶心不已，确实那么的无法自拔，有人作陪那是极好的。\n未来小展望 进入了工作当中，姜文说，谁会把秘密写到日记中去呀。（PS：有点想念上学看一步之遥的日子了），人在看的似懂非懂的时候是最装B的，就是不管生活之中遇到了什么情况，都得和差一步，一步之遥搭上关系。诶呀，又想歪了。前一阵儿，认识了个姑娘，当时喝多了晚上，唱歌认识的，就聊，硬聊。第二天，干什么都变得不一样了，和哥们打游戏都感觉变猛了。姑娘说：你是不是今天做的所有的事情都得和我搭上关系（呼应）。深思呀~~~，人是贱的，可能我是，总是把自己所期望的，变成所期望的，从而让自己认同期望的，太一厢情愿了，尤其是小男生，所以，才有了人生三大幻觉，所以，谨此告诫各位小男生，放弃幻想，认清现实，不要感动自我，更不要你以为。（哦又差题了）\n聊未来，小弟进入了一家正在改制的事业单位，虽说也是央企，可学地质的进这种不是宛如喝凉水一般，我是不幸的，也是幸运的，作为49年入国军的我，在工作之中遇到这么多趣人趣事，最开心的莫过于，斗争就在你眼前。我发现现在的人都冲浪的很喜欢吃瓜，虽然与我无瓜，但他就是要吃一口。嗯，大戏就在我眼前，我终于体会到前排VIP的观感了，精彩，精彩绝伦。\n听单位的前辈哥哥们说，他们看到我，就看到了十年前的自己，嗯，说不好，说不准未来如何，但我不求出彩，尽力精彩。\n引用人民日报的一句话，做时代的弄潮儿，勇立潮头。\n都说秘密不会写在日记里 -Jw 2022.09.19 21:14\r","permalink":"https://www.jaywxl.eu.org/posts/life/5_firth/","summary":"感慨汉中的小生活😛","title":"Notes | 汉中小随笔"},{"content":"miniapp 原网站jt.jaywxl.asia\r,因为校园保卫人员职业素养的提升，网站形成的假条已经被废弃。\n现在已经将假条项目迁移至小程序。\n可以微信搜索Jaywxl ![jpg](/images/jaymini.jpg =200×) 本项目所有源码都在GitHub开源(ps:后端还未完成push) 感谢各位校友的支持，请勿外传，有更好css想法的朋友，可以在下方评论！😘\n","permalink":"https://www.jaywxl.eu.org/posts/life/4_miniapp/","summary":"XUST 我在校园 请假小程序","title":"Miniapp"},{"content":"xust实现全自动打卡 这是个令人激动的时刻对于我们来说\n这个项目让我们告别了每天繁琐的五点打卡\n导员的催促、班委的通知\n却也还是总让我们忘记，从而得到导员温柔的问候\n接下来开始正体 所需软体和条件\n一个可以手机抓包的软件(ps:还没看pc版的西科e站包在哪里，后续可能回更新) 你需要你个登录了西科e站的微信app 需要一个富强的环境(ps:当然GitHub也可以不，会很慢🤣🤣) 1.首先打开抓包软体,找到如下图所示的包 获uid! uidpc\ruid1\ruid2\r2.电脑登入西科e站,f12,点打卡提交后,找到如下的包,获得最下边的payload! payload\r3.有了上边两个步骤之后,访问我的项目地址,并且fork我的仓库Checkin\r,并替换python文件里的uid,payload,自此今后的打卡就会上传你payload的信息! GitHub\rps:当然你可以替换文件里的sckey,从此获得消息推送,如出现{}字符,即为打卡成功\n感谢你的观看❤😁 ","permalink":"https://www.jaywxl.eu.org/posts/life/3_third/","summary":"XUST 疫情期间 自动打卡","title":"XUST 自动打卡"},{"content":"很喜欢的一个西安本地公众号，贞观。记得那天中午看到这篇文字，久久不能平复，看了很多遍文章，把它分享给了我的好几个好友群，不知道怎么地了，上班了后就变得很想关注社会、人文，telegram、youtube看的也不多了，以前看那种事情看个乐子，总想看黑暗面。现在看东西更喜欢向阳光的方向考虑，考虑到底为什么是这样，是因为所处的环境、社会的文化、人的认知等等方面。那中午每次看文章，总会去读新评论，也总有人用一种居高临下的口吻在讲“如今这社会还能饿死人···送个外卖也饿不死呀···211毕业的大学生随便当个出纳都死不了···父母养了30多年，毕业了也要父母养着，房租都得父母来凑，住那么贵的房子，就非得考个公务员···”，如今文字被贞观隐入尘埃，互联网上质疑声一片。我个人相信文章的真实性的，故记录下心情并珍藏故事，让我在一个人的时候，也能多多体悟这世道。\n原文转载 体悟 其实没什么感悟的，人已经在彼岸了，不会有人知道她死去时的真实想法。\n她以饿死自己这样方式自杀，她拉黑掉所有亲戚的联系方式，她在繁华街巷昂贵出租屋中悄然死去\u0026hellip;\n我想她是屈服于这个世界，倦了\n她缺乏生活能力，连拙劣的骗子也不能辨别；她多次考公笔试第一，面试被刷\u0026hellip;\n我想她是想对抗这个世界，败了\n她考上211，血肉至亲也没能敌过家乡的恶俗，父母的固有观念；\n我想她是想热爱这个世界，麻了\n个人的猜想，女陔努力考入北京211，却因生活背景、自身性格不能很好的融入，毕业父母希望光耀门楣，考上公务员，不惜借贷搭入全部身家。孩子因自身性格一步步的失败/不甘心，最终坠入深渊\u0026hellip;\n我想这更多是社会文化的问题，是不先进的、不符合事物发展规律的文化造就了乡土文化，培育了父母，影响了孩子。 可是怎么总结先进文化、怎么宣扬先进文化、怎么践行遵守事物规律，更值得社会大众好好探讨。 逝者安息🙏\n- by Jaywxl\nMon,Aug 19 2024 ","permalink":"https://www.jaywxl.eu.org/posts/life/12_yigewaidinvhaisizailechuzugongyu/","summary":"很喜欢的一个西安本地公众号，贞观。记得那天中午看到这篇文字，久久不能平复，看了很多遍包括评论。如今文字被贞观隐入尘埃，互联网上质疑声一片。我个人相信文章的真实性，故记录下心情并珍藏文字\u0026hellip;","title":"Notes | 转存贞观文章《一个外地女孩，死在了我出租的公寓》"},{"content":" 很久没有写过blog了，最近真的是挺忙的（都是借口🤣）， 爬完山太累了、 喝完酒太累了、 上完班太累了、 看书也太累了\u0026hellip; 都是借口的啦　呜呜~~~ 那就总结下最近的事情吧，一会儿再写一篇最近读的书 （好久没写作文，真的是语言组织能力渣到爆欸:(）\n爬山 爬山作为我工作中经常需要做的事情，放假爬山我一直还蛮不想干的。\n小陈从内蒙的煤矿回来，辞职了\u0026hellip;我身边的地质同学几乎都辞职一轮了（工作了的），煤矿的工作非常辛苦而且危险，环境还非常的差劲，记得有一次他们分享照片，刚从煤矿爬上来的他们，除了口罩遮住的地方，满脸都黑了，真的是“从煤球里爬出来的”。\n小陈回家路过西安，开着他的哈弗大狗（薪资水平还不错），看起来很是轻松，我们也为他高兴，老同学来了总得聚聚。作为我们宿舍最喜欢花活、最讲究的人，小凡果不其然想出了一个好活\u0026ndash;爬华山！他们俩一道给我软磨硬泡。\n一个节假日的早晨，冬天的早晨天才微微亮，蓝色的天空很透彻，没有一片云彩，阳光还未探出地平线，泛着的“鱼肚白”接着那片湛蓝，很是好看\u0026hellip;其实这些都是我编的，因为七点从地铁站出来到纺织城，我的眼睛应该还没有睁开。\n坐上了大狗，想着华县出发了，虽然我很不想空余时间来爬山，不过也是还算有趣。一是和朋友们在一起有意思，群居动物嘛。二是华山五岳险之最还是挺好玩的。中途小插曲，有笨b高速口下错了。\n上山的路线我们选择了“西上北下”，风险较低，较为平缓。去北峰索道的路上，反正我向下是挺害怕的，不知道这种路向上得多刺激😂上山索道的路上遇到一个母亲带着孩子和孩子姥姥，小孩子果然是天不怕地不怕，坐在索道车厢里竟然走来走去，不知道为什么我小时候没有这么勇。爬升的路上两个地质好学生竟然还在看共轭节理，我已经晕头转向、脚趾紧扣了。索道站竟然是开在绝壁之上的，“脚踏实地”的感觉太棒了，出站后简单的在庙里休整了就向着西峰峰顶进发了。登顶就是那么索然无味，看着远处青龙背上的人们，我都替他们捏把汗。最之后接连攀登了几座主峰后，绕到了北峰下山，这两位优秀的地质工作者，环着华山几个山头跑了一圈，愣是一步都没让我歇着，下午竟然早早就完事回家了。下山来到县城吃了我第一顿塔斯汀，就那样\u0026hellip;晚上绕了半个西安城，就为了找个大澡堂子，结果里面也是人山人海，草草收场了\u0026hellip;哦想起来了这是23年的12月30号，第二天我们一起在绿树度过了美好的跨年夜\u0026hellip;（全文的\u0026hellip;都体现出了我的无法言说的无感，但和兄弟们在一起还是很开心的:)）\n送走了小陈，日子没过多久，就有和一对bren爬山了，这次是终南山，这个山其实我还挺想去的，想看看到底有没有活死人墓，结果上山下山一路都在拍照，这是我买了相机后第一次旅游拍照，出了几张，凑合看吧。\n喝酒 去终南山是经过我们谋划的，那一夜，不知买了多少醉。也留下了这组精彩的照片。 img\n- by Jaywxl\nFri,Apr 12 2024 ","permalink":"https://www.jaywxl.eu.org/posts/life/11_huashanzhixing_jiazhongxiaoju/","summary":"很久没有写过blog了，最近真的是挺忙的（都是借口🤣）， 爬完山太累了、 喝完酒太累了、 上完班太累了、 看书也太累了\u0026hellip; 都是借口的啦 呜","title":"Notes | 华山旅游\u0026终南山\u0026近期小酌小聚"},{"content":"何来 想拽很多文，但肚子里墨水不够。hhh:)\n前一段时间，想挑一本书看看，学习学习，虽然租赁了一间离省图很近的房子，但借书观看真的对我来说，有些囫囵吞枣的感觉，还没怎么看完、看明白就要归还了，且借书也是个难搞的过程，想看的借不到，只能匆匆 在图书馆选一本。最近在那选了一本《台湾建筑史》，我只想说说\u0026hellip;shit\u0026hellip;，这是一本零几年的书，书中所讲的建筑史，大多属于明清时期的历史，最新的也是台北101大楼了。 我不知道这些建筑还留存多少。只记得好像荷兰来建了个“红毛城”（如果我没记错的话-_-），明清和福建往来密切，有大陆的建材、匠人前往建设，再后来就是日治时期（日本也去过，不知道这段历史欸），最后就是近代几个建筑师的介绍，什么学舍、图书馆、车站、纵贯线的公园、还有101大楼。101应该是他们较为骄傲的建筑了吧，在零几年的东方，建设亚洲最高的摩天大楼，其中甚至还包含佛教等等的思想，蛮不错的欸湾湾！\n我个人还是很喜欢台湾的，经济发达是由道理的，我想我也会很喜欢宝岛的自然风光，人文景观，毕竟谁不爱\u0026hellip;\n说到儒释道，又得提起我最近看的一部剧集啦\u0026ndash;《天道》，张志文、左小青演的，演技挺不错的，我认为张志文肯定是理解台词了的，不然怎么将演技和台词搭配的如此入境。\n神及道，道法自然，如是\n神及道，道即规律，遵规律者则为神\n下面这句是左小青的理解，元英遵规律，用农户式生产的方式，遵循消费者所在的市场规律、利用行业头部的运作规律，打倒了乐圣，形成了杀富济贫的效果。但真的济贫了吗，我认为否定的，那些扒着井口看一眼的人，再次摔了下去。\n救济的只是身体的贫穷、爱的贫穷。亚文、世杰思想富裕。\n要不鲁迅弃医从文 :(\n说回苏轼啦！书的封面是这么评价的\n一蓑烟雨任平生\n苏轼的一生可以概括为，黄州惠州儋州\n就这样，我买了王水照先生的《苏轼转》与《苏轼选集》，想一睹超然的东坡居士，评评他是否有这境界🤣\n理解 最近做了两遍MBTI的测试，我是enfj，这很稀缺吗？她说全球只有3-5%。\n超脱 苏轼被贬至密州，做了超然台记。超然我没读懂😂，我想这苏轼再怎么读《庄子》，也不能超然物外吧。 密州时期我必然最喜欢《江城子·密州出猎》。当然同期他还做了《兼怀子由》。\n老夫聊发少年狂，左牵黄，右擎苍，锦帽貂裘，千骑卷平冈。为报倾城随太守，亲射虎，看孙郎。 酒酣胸胆尚开张。鬓微霜，又何妨！持节云中，何日遣冯唐？会挽雕弓如满月，西北望，射天狼。\n此刻的出猎场景，描绘的狂。此时的苏轼心情，我想的伤。\n密州的环境比不上余杭，诗人在杭州赏尽湖光烟雨，喝遍美酿佳肴，参加全了风雅集会。我是实名（Jw）羡慕的。 钱塘江的春潮，戏水的弄潮儿；\n湖光山色中的千年古刹，端重的高僧。东坡在这过的挺爽的，从海南回来，是我我肯定选杭州乞居。\n超脱是超脱不了了，我物欲很强的，hh 我也经常去人迹罕至的山水林田湖草，我也相信“神及道，道法自然，如是”，可能我也超然吧。\n- by Jaywxl\nMon,Nov 13 2023 ","permalink":"https://www.jaywxl.eu.org/posts/life/10_dong_po_ju_shi/","summary":"何来 想拽很多文，但肚子里墨水不够。hhh:) 前一段时间，想挑一本书看看，学习学习，虽然租赁了一间离省图很近的房子，但借书观看真的对我来说，有","title":"Notes | 读《苏轼传》感"},{"content":" sql_Rank()函数 编写 SQL 查询对分数进行排序。排名按以下规则计算:\n分数应按从高到低排列。 如果两个分数相等，那么两个分数的排名应该相同。 在排名相同的分数后，排名数应该是下一个连续的整数。换句话说，排名之间不应该有空缺的数字。 按 score 降序返回结果表。\n查询结果格式如下所示。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 示例 1: 输入: Scores 表: +----+-------+ | id | score | +----+-------+ | 1 | 3.50 | | 2 | 3.65 | | 3 | 4.00 | | 4 | 3.85 | | 5 | 4.00 | | 6 | 3.65 | +----+-------+ 输出: +-------+------+ | score | rank | +-------+------+ | 4.00 | 1 | | 4.00 | 1 | | 3.85 | 2 | | 3.65 | 3 | | 3.65 | 3 | | 3.50 | 4 | +-------+------+ 来源：力扣（LeetCode）\n链接：https://leetcode.cn/problems/rank-scores\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\nrank\rrank()相关函数的使用\n1 2 3 4 5 6 7 8 9 # Write your MySQL query statement below select score, dense_rank() over (order by score desc) as \u0026#39;rank\u0026#39; #这个rank之所以要加引号，因为rank本身是个函数，直接写rank会报错 from scores; -- 异或这种count1前面的数据 select a.Score,(select count(distinct b.Score) from Scores b where b.Score \u0026gt;= a.Score) as \u0026#39;rank\u0026#39; from Scores a order by a.Score DESC; ","permalink":"https://www.jaywxl.eu.org/posts/study/15_stu/","summary":"sql_Rank()函数 编写 SQL 查询对分数进行排序。排名按以下规则计算: 分数应按从高到低排列。 如果两个分数相等，那么两个分数的排名应该相同。 在","title":"15_stu"},{"content":" 数组之求和为k的连续子数组数量 给你一个整数数组 nums 和一个整数 k ，请你统计并返回 该数组中和为 k 的连续子数组的个数 。\n示例 1：\n输入：nums = [1,1,1], k = 2 输出：2\n示例 2：\n输入：nums = [1,2,3], k = 3 输出：2\n来源：力扣（LeetCode）\n链接：https://leetcode.cn/problems/subarray-sum-equals-k\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n使用的原理就是 presum-k 若在 之前哈希表中的 presum 出现过 那么 必定有连续的数组和为k\n因为之前统计的presum为一段连续数组，现如今的presum同为连续数组，两个连续数组相减，和为k的数组也必为连续数组\n若presum在哈希表中不唯一 表示连续数组中出现了和为0的子数组。\n111\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution: def subarraySum(self, nums: List[int], k: int) -\u0026gt; int: prehash = dict() prehash[0] = 1 preSum = 0 count = 0 for num in nums: preSum += num if preSum - k in prehash: count += prehash[preSum - k] if preSum not in prehash: prehash[preSum] = 1 else: prehash[preSum] += 1 return count ","permalink":"https://www.jaywxl.eu.org/posts/study/14_stu/","summary":"数组之求和为k的连续子数组数量 给你一个整数数组 nums 和一个整数 k ，请你统计并返回 该数组中和为 k 的连续子数组的个数 。 示例 1： 输入：nums = [1,1,1], k =","title":"14_stu"},{"content":" 写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target 。该矩阵具有以下特性：\n每行的元素从左到右升序排列。\n每列的元素从上到下升序排列。 img\r来源：力扣（LeetCode）\n链接：https://leetcode.cn/problems/search-a-2d-matrix-ii\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 \u0026#34;\u0026#34;\u0026#34; * 二分法 * z字型搜索 从右上角 两个边界数值 一大一小的地方 开启搜索 各向异性 \u0026#34;\u0026#34;\u0026#34; Method_二分法 class Solution: def searchMatrix(self, matrix: List[List[int]], target: int) -\u0026gt; bool: for row in matrix: idx = bisect.bisect_left(row, target) if idx \u0026lt; len(row) and row[idx] == target: return True return False Method_z字型法则 \u0026#34;\u0026#34;\u0026#34; 从右上角 或 左下角 开始搜索 满足两个方向的不同 \u0026#34;\u0026#34;\u0026#34; class Solution: def searchMatrix(self, matrix: List[List[int]], target: int) -\u0026gt; bool: m, n = len(matrix), len(matrix[0]) x, y = 0, n - 1 while x \u0026lt; m and y \u0026gt;= 0: if matrix[x][y] == target: return True if matrix[x][y] \u0026gt; target: y -= 1 else: x += 1 return False ","permalink":"https://www.jaywxl.eu.org/posts/study/13_stu/","summary":"写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target 。该矩阵具有以下特性： 每行的元素从左到右升序排列。 每列的元素从上到下升序排列。 img 来源：力扣","title":"13_stu"},{"content":" 01_二叉搜索树公共祖先 给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。\n百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”\n例如，给定如下二叉搜索树: root = [6,2,8,0,4,7,9,null,null,3,5]\n公共祖先\r示例 1:\n输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8 输出: 6 解释: 节点 2 和节点 8 的最近公共祖先是 6。\n来源：力扣（LeetCode） 链接：https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None \u0026#34;\u0026#34;\u0026#34; 巧妙的运用了二叉树搜索的条件定义，左中右三个值的大小关系 \u0026#34;\u0026#34;\u0026#34; class Solution: def lowestCommonAncestor(self, root: \u0026#39;TreeNode\u0026#39;, p: \u0026#39;TreeNode\u0026#39;, q: \u0026#39;TreeNode\u0026#39;) -\u0026gt; \u0026#39;TreeNode\u0026#39;: small,big=(p,q) if p.val\u0026lt;q.val else (q,p) if small.val\u0026lt;=root.val: if big.val\u0026gt;=root.val: return root else: return self.lowestCommonAncestor(root.left,p,q) else: return self.lowestCommonAncestor(root.right,p,q) ","permalink":"https://www.jaywxl.eu.org/posts/study/12_stu/","summary":"01_二叉搜索树公共祖先 给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p","title":"12_stu"},{"content":" Target\rsee 动态规划 init github\u0026quot;stock_trade\u0026quot; and ReadMe 02_路径总和 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right # class Solution: # def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -\u0026gt; bool: # if root: # targetSum = targetSum - root.val # else: # return False # stack = [] # sum = [] # while root: # print(root) # a,b = float(\u0026#39;-inf\u0026#39;),float(\u0026#39;-inf\u0026#39;) # if root.left: a = root.left.val # if root.right: b = root.right.val # if root.right and root.left: # stack.append(root) # sum.append(targetSum) # if a \u0026gt; b : # targetSum -= a # root = root.left # else: # targetSum -= b # root = root.right # print(root) # if targetSum != 0 and not root.left and not root.right and stack: # root = stack.pop() # targetSum = sum.pop() # if root.right.val \u0026gt; root.left.val: # root.right = None # else: # root.left = None # elif targetSum == 0 and not root.left and not root.right: # return True # elif targetSum != 0 and not root.left and not root.right: # return False \u0026#34;\u0026#34;\u0026#34; 最终被击溃在两个子节点数值相等的问题上导致无法回溯，可以优化存在栈里面回溯的treenode，将选择的一边设为None \u0026#34;\u0026#34;\u0026#34; Method_递归 class Solution(object): def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -\u0026gt; bool: if not root: return False if not root.left and not root.right: return targetSum == root.val return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val) 02_搜索二叉树 搜索二叉树满足对于任意节点 root 而言，左子树（如果存在）上所有节点的值均小于 \\textit{root.val}root.val，右子树（如果存在）上所有节点的值均大于 \\textit{root.val}root.val，且它们都是二叉搜索树。 递归\ninit_stock_trade ","permalink":"https://www.jaywxl.eu.org/posts/study/11_stu/","summary":"Target see 动态规划 init github\u0026quot;stock_trade\u0026quot; and ReadMe 02_路径总和 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 # Definition for","title":"11_stu"},{"content":" 二叉树 img\r最重点的内容就是：不管是先序中序还是后序，查找流程都是从上到下，先左后右。只是输出的时机不同。\n先序就是发现了先输出，再先左后右。\n中序就是发现了先存着，当左边遍历完了，再把存着的输出出来。\n后序就是发现了先存着，当左边和右边都遍历完了，再把存着的输出出来。\n01_二叉树前序 Method:迭代\n1 2 3 4 5 6 7 8 9 10 11 class Solution: def preorderTraversal(self, root: TreeNode) -\u0026gt; List[int]: if not root: return [] stack = [root] res = [] while stack : p = stack.pop() res.append(p.val) if p.right: stack.append(p.right) if p.left: stack.append(p.left) return res 02_二叉树中序 Method:递归\n1 2 3 4 5 6 7 8 9 10 11 class Solution: def inorderTraversal(self, root: Optional[TreeNode]) -\u0026gt; List[int]: res=list() def midorder(root:TreeNode): if not root: return midorder(root.left) res.append(root.val) midorder(root.right) midorder(root) return res 03_二叉树后序 Method:迭代\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution: def postorderTraversal(self, root: Optional[TreeNode]) -\u0026gt; List[int]: res=[] if not root: return res node=root stack=[] while stack or node: while node: res.append(node.val) stack.append(node) node=node.right node=stack.pop() node=node.left return res[::-1] ","permalink":"https://www.jaywxl.eu.org/posts/study/10_stu/","summary":"二叉树 img 最重点的内容就是：不管是先序中序还是后序，查找流程都是从上到下，先左后右。只是输出的时机不同。 先序就是发现了先输出，再先左后右。 中序","title":"10_stu"},{"content":" 01_栈_哈希表_有效括号 给定一个只包括 \u0026lsquo;(\u0026rsquo;，\u0026rsquo;)\u0026rsquo;，\u0026rsquo;{\u0026rsquo;，\u0026rsquo;}\u0026rsquo;，\u0026rsquo;[\u0026rsquo;，\u0026rsquo;]\u0026rsquo; 的字符串 s ，判断字符串是否有效。\n有效字符串需满足：\n左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 每个右括号都有一个对应的相同类型的左括号。 示例 1：\n输入：s = \u0026ldquo;()\u0026rdquo; 输出：true\n示例 2：\n输入：s = \u0026ldquo;()[]{}\u0026rdquo; 输出：true\n示例 3：\n输入：s = \u0026ldquo;(]\u0026rdquo; 输出：false\n来源：力扣（LeetCode） 链接：https://leetcode.cn/problems/valid-parentheses 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 栈的思想\r{([])} 利用先进后出的原则来判断括号是否闭合\n每个stack的-1位置需要和dic字典里的键值对相互对应\n1 2 3 4 5 6 7 8 9 10 11 12 class Solution: def isValid(self, s: str) -\u0026gt; bool: dic = {\u0026#39;)\u0026#39;:\u0026#39;(\u0026#39;,\u0026#39;]\u0026#39;:\u0026#39;[\u0026#39;,\u0026#39;}\u0026#39;:\u0026#39;{\u0026#39;} stack = [] for i in s: if stack and i in dic: if stack[-1] == dic[i]: stack.pop() else: return False else: stack.append(i) return not stack ","permalink":"https://www.jaywxl.eu.org/posts/study/08_09_stu/","summary":"01_栈_哈希表_有效括号 给定一个只包括 \u0026lsquo;(\u0026rsquo;，\u0026rsquo;)\u0026rsquo;，\u0026rsquo;{\u0026rsquo;，\u0026r","title":"08_09_stu"},{"content":"1_链表_判断是否有环 开启链表的学习主要是快慢指针方法 或者 用哈希表的方法 leecode_链表\r输入：head = [3,2,0,-4], pos = 1 输出：true 解释：链表中有一个环，其尾部连接到第二个节点。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 # Definition for singly-linked list. # class ListNode: # def __init__(self, x): # self.val = x # self.next = None class Solution: def hasCycle(self, head: ListNode) -\u0026gt; bool: # 空链表或链表只有一个节点，无环 if not head or head.next == None: return False # 初始化快慢指针 fast = slow = head # 如果不存在环，肯定 fast 先指向 null # 细节：fast 每次走 2 步，所以要确定 fast 和 fast.next 不为空，不然会报执行出错。 while fast and fast.next: # 快指针移动 2 步，慢指针移动 1 步 fast = fast.next.next slow = slow.next # 快慢指针相遇，有环 if fast == slow: return True return 2_链表递归 给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。 示例 1： 2\r输入：head = [1,2,6,3,4,5,6], val = 6 输出：[1,2,3,4,5] 示例 2：\n输入：head = [], val = 1 输出：[] 示例 3：\n输入：head = [7,7,7,7], val = 7 输出：[]\n来源：力扣（LeetCode） 链接：https://leetcode.cn/problems/remove-linked-list-elements 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n1 2 3 4 5 6 7 8 9 10 11 12 class Solution: def removeElements(self, head: Optional[ListNode], val: int) -\u0026gt; Optional[ListNode]: if not head: return head if head.val == val : head = self.removeElements(head.next,val) return head else: # self.removeElements(head.next,val) 错误是否需要前面先赋值，否则return的怎么返回 eg下方正确方式 head.next = self.removeElements(head.next,val) return head ","permalink":"https://www.jaywxl.eu.org/posts/study/07_stu/","summary":"1_链表_判断是否有环 开启链表的学习主要是快慢指针方法 或者 用哈希表的方法 leecode_链表 输入：head = [3,2,0,-4], pos = 1 输出：true 解释：链表","title":"07_stu"},{"content":" 01_adddate 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 输入： Weather 表： +----+------------+-------------+ | id | recordDate | Temperature | +----+------------+-------------+ | 1 | 2015-01-01 | 10 | | 2 | 2015-01-02 | 25 | | 3 | 2015-01-03 | 20 | | 4 | 2015-01-04 | 30 | +----+------------+-------------+ 输出： +----+ | id | +----+ | 2 | | 4 | +----+ 解释： 2015-01-02 的温度比前一天高（10 -\u0026gt; 25） 2015-01-04 的温度比前一天高（20 -\u0026gt; 30） 来源：力扣（LeetCode） 链接：https://leetcode.cn/problems/rising-temperature 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 1 2 3 4 5 -- ADDDATE函数日期增加 -- inner join内连接 会删除没有匹配的项 不会保留null SELECT id from Weather w1 left join (SELECT ADDDATE(recordDate,1) as uid,Temperature as t from Weather)w2 on w1.recordDate = w2.uid WHERE Temperature \u0026gt; t; 02_判断两个字符串中元素是否一样多 1 2 3 4 5 6 7 8 9 10 import collections s = \u0026#34;ab\u0026#34; t = \u0026#34;ba\u0026#34; class Solution: def firstUniqChar( s: str, t: str) -\u0026gt; bool: # print(sorted(collections.Counter(t).most_common())) # print(collections.Counter(t).most_common()) sorted()排序 return sorted(collections.Counter(s).most_common()) == sorted(collections.Counter(t).most_common()) print(Solution.firstUniqChar(s,t)) ","permalink":"https://www.jaywxl.eu.org/posts/study/06_stu/","summary":"01_adddate 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 输入： Weather 表： +----+------------+-------------+ | id | recordDate | Temperature | +----+------------+-------------+ | 1 | 2015-01-01 | 10 | | 2 | 2015-01-02 | 25 | | 3 | 2015-01-03 | 20 | | 4 | 2015-01-04 | 30 | +----+------------+-------------+ 输","title":"06_stu"},{"content":"\u0026hellip; 01_sql 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 给定一个表 tree，id 是树节点的编号， p_id 是它父节点的 id 。 +----+------+ | id | p_id | +----+------+ | 1 | null | | 2 | 1 | | 3 | 1 | | 4 | 2 | | 5 | 2 | +----+------+ 树中每个节点属于以下三种类型之一： 叶子：如果这个节点没有任何孩子节点。 根：如果这个节点是整棵树的根，即没有父节点。 内部节点：如果这个节点既不是叶子节点也不是根节点。 写一个查询语句，输出所有节点的编号和节点的类型，并将结果按照节点编号排序。上面样例的结果为： +----+------+ | id | Type | +----+------+ | 1 | Root | | 2 | Inner| | 3 | Leaf | | 4 | Leaf | | 5 | Leaf | +----+------+ 来源：力扣（LeetCode） 链接：https://leetcode.cn/problems/tree-node 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 -- case when Method select id, case when p_id is NULL then \u0026#39;Root\u0026#39; when id in ( select atree.p_id from tree as atree ) then \u0026#39;Inner\u0026#39; else \u0026#39;Leaf\u0026#39; end as type from tree -- if else Method SELECT id, IF(p_id IS NULL, \u0026#39;Root\u0026#39;, IF(id IN ( SELECT DISTINCT p_id FROM tree WHERE p_id IS NOT NULL ),\u0026#39;Inner\u0026#39;,\u0026#39;Leaf\u0026#39;) ) AS Type FROM tree 02_limit_offset_sql 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 Employee 表： +-------------+------+ | Column Name | Type | +-------------+------+ | id | int | | salary | int | +-------------+------+ id 是这个表的主键。 表的每一行包含员工的工资信息。 编写一个 SQL 查询，获取并返回 Employee 表中第二高的薪水 。如果不存在第二高的薪水，查询应该返回 null 。 查询结果如下例所示。 示例 1： 输入： Employee 表： +----+--------+ | id | salary | +----+--------+ | 1 | 100 | | 2 | 200 | | 3 | 300 | +----+--------+ 输出： +---------------------+ | SecondHighestSalary | +---------------------+ | 200 | +---------------------+ 来源：力扣（LeetCode） 链接：https://leetcode.cn/problems/second-highest-salary 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 1 2 3 4 5 6 7 8 9 -- LIMIT 返回一步 OFFSET 跳过一步 DESC 倒序排列 SELECT (SELECT DISTINCT Salary FROM Employee ORDER BY Salary DESC LIMIT 1 OFFSET 1) AS SecondHighestSalary ; 03_数独游戏 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 def isValidSudoku(): board = [[\u0026#34;8\u0026#34;,\u0026#34;3\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;7\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;] ,[\u0026#34;6\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;9\u0026#34;,\u0026#34;5\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;] ,[\u0026#34;.\u0026#34;,\u0026#34;9\u0026#34;,\u0026#34;8\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;6\u0026#34;,\u0026#34;.\u0026#34;] ,[\u0026#34;8\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;6\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;3\u0026#34;] ,[\u0026#34;4\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;8\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;3\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;1\u0026#34;] ,[\u0026#34;7\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;2\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;6\u0026#34;] ,[\u0026#34;.\u0026#34;,\u0026#34;6\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;2\u0026#34;,\u0026#34;8\u0026#34;,\u0026#34;.\u0026#34;] ,[\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;4\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;9\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;5\u0026#34;] ,[\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;8\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;7\u0026#34;,\u0026#34;9\u0026#34;]] \u0026#39;\u0026#39;\u0026#39; 哈希算法 row,col,block分别生成的依据是9行*9个数字、9列*9个数字、9块*9个数字 在判断相同行列块中数字是否变成了赋值的1 从而return 不能 使用 [[0] *9]*9 这样第二个九相当于引用了9遍列表[[0] * 9] 会出现修改后数值都变 exp: [[1,0,0,0],[1,0,0,0],[1,0,0,0],[1,0,0,0]] \u0026#39;\u0026#39;\u0026#39; row = [[0] * 9 for _ in range(9)] col = [[0] * 9 for _ in range(9)] block = [[0] * 9 for _ in range(9)] for i in range(9): for j in range(9): if board[i][j] != \u0026#39;.\u0026#39;: num = int(board[i][j]) - 1 print(num) b = (i // 3) * 3 + j // 3 print(b) if row[i][num] or col[j][num] or block[b][num]: print(block) return False row[i][num] = col[j][num] = block[b][num] = 1 return True \u0026#39;\u0026#39;\u0026#39; Method 2 ： 生成三种数组，再将合并成一种数组，遍历其中的counter，看每个的计数情况是否为 0，1 改进 判断哈希赋值 32ms,99% \u0026#39;\u0026#39;\u0026#39; # n = list(map(list,zip(*board))) # nn,nnn = [],[] # for a in board: # nn += a # ab = [nn[i:i+3] for i in range(0,len(nn),3)] # for b in [0,1,2,9,10,11,18,19,20]: # nnn += [ab[b]+ab[b+3]+ab[b+6]] # num = board+n+nnn for i in num: nnnn = [0]*9 for a in i: if a != \u0026#39;.\u0026#39;: n = int(a) - 1 if nnnn[n] == 1: return False nnnn[n] = 1 return True # rs = 0 # for a in range(len(num)): # count = Counter(num[a]) # for i in range(1,10): # if count[str(i)] not in [0,1]: # rs += 1 # return False # else: continue # if rs == 0 : return True ","permalink":"https://www.jaywxl.eu.org/posts/study/05_stu/","summary":"\u0026hellip; 01_sql 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 给定一个表 tree，id 是树节点的编号， p_id 是它父节点的 id 。 +----+------+ | id | p_id | +----+------+","title":"05_stu"},{"content":" 01_数组切片分组 1 2 3 4 5 6 7 8 9 10 11 12 mat = [[1,2],[3,4],[5,6]] r,c = 2,3 ans = [[0]*c for _ in range(r)] a = [] class Solution: def matrixReshape(self, mat: List[List[int]], r: int, c: int) -\u0026gt; List[List[int]]: if len(mat)*len(mat[0]) == r*c : for i in mat: a +=i return [a[i:i + c] for i in range(0, len(a), c)] else: return mat 02_杨辉三角 杨辉三角\n弄清yieid 和 return 区别 yieid可迭代\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution: def triangles(b): L = [1] i = 0 #定义L为一个只包含一个元素的列表 while i \u0026lt; b: i += 1 yield L #定义为生成器函数 L =[1] + [L[n] + L[n-1] for n in range(1,len(L))] + [1] def generate(self, numRows: int) -\u0026gt; list[list[int]]: n = [] for a in Solution.triangles(numRows): print(a) n.append(a) return n # 方法二 简化 L = [1] i = 0 #定义L为一个只包含一个元素的列表 n = [] while i \u0026lt; b: i += 1 n.append(L) L =[1] + [L[n] + L[n-1] for n in range(1,len(L))] + [1] return n ","permalink":"https://www.jaywxl.eu.org/posts/study/04_stu/","summary":"01_数组切片分组 1 2 3 4 5 6 7 8 9 10 11 12 mat = [[1,2],[3,4],[5,6]] r,c = 2,3 ans = [[0]*c for _ in range(r)] a = [] class Solution: def matrixReshape(self, mat: List[List[int]], r: int, c: int) -\u0026gt; List[List[int]]: if len(mat)*len(mat[0]) == r*c : for i in mat: a +=i return [a[i:i + c] for i in range(0, len(a), c)]","title":"04_stu"},{"content":" 01_返回交集 给你两个整数数组 nums1 和 nums2 ，请你以数组形式返回两数组的交集。返回结果中每个元素出现的次数，应与元素在两个数组中都出现的次数一致（如果出现次数不一致，则考虑取较小值）。可以不考虑输出结果的顺序。 示例 1：\n输入：nums1 = [1,2,2,1], nums2 = [2,2] 输出：[2,2] 示例 2:\n输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4] 输出：[4,9]\n来源：力扣（LeetCode） 链接：https://leetcode.cn/problems/intersection-of-two-arrays-ii 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from collections import Counter import collections nums1 = [1,2,1,3] nums2 = [2,2,3] nn = [] n = 1 count = Counter(nums1) print(count[4]) ans = [] for num in nums2: if count[num] != 0: print(count) ans.append(num) count[num] -= 1 print(ans) c = (collections.Counter(nums1)\u0026amp;collections.Counter(nums2)).elements() # 一行代码 print(c) d = nums1\u0026amp;nums2 print(d) 02_concat_upper_lower_sql 1 2 3 4 5 6 CONCAT # 拼接字符串 LEFT,RIGHT UPPER,LOWER # 大写，小写 select user_id, CONCAT(UPPER(left(name, 1)), LOWER(RIGHT(name, length(name) - 1))) as name from Users order by user_id; 03_sql 1 2 3 4 5 6 7 -- group_concat 字符串连接 -- group by 分组 -- count 统计 -- distinct 去重 select sell_date, count(distinct(product)) as num_sold, group_concat(distinct product order by product asc separator \u0026#39;,\u0026#39;) as products from Activities group by sell_date; 04_sql 1 2 3 4 select patient_id,patient_name,conditions from PAtients where conditions regexp \u0026#39;^DIAB1|\\\\sDIAB1\u0026#39;; # 正则表达式 where conditions like \u0026#39;DIAB1%\u0026#39; or conditions like \u0026#39;% DIAB1%\u0026#39; #like的匹配得有百分号（类似于*） 否则该语句等同于= ","permalink":"https://www.jaywxl.eu.org/posts/study/03_stu/","summary":"01_返回交集 给你两个整数数组 nums1 和 nums2 ，请你以数组形式返回两数组的交集。返回结果中每个元素出现的次数，应与元素在两个数组中都出现的次数一致（如","title":"03_stu"},{"content":"01_找出出现一次的元素(reduce) 给你一个 非空 整数数组 nums ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。\n你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。\n来源：力扣（LeetCode）\n链接：https://leetcode.cn/problems/single-number\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\nreduce函数累计 a^b^c^d^\u0026hellip;.\n异或 不同输出本身 时间复杂度O(1) 空间复杂度O(n)\n1 2 3 4 5 6 7 from functools import reduce nums = [1,2,3,4,4,3,2] class Solution: def singleNumber(nums: list[int]) -\u0026gt; int: return reduce(lambda x,y : x^y,nums) print(Solution.singleNumber(nums)) 02_update_sql方法(ascii,if方法,case when) Salary 表：\n+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-+\u0026mdash;\u0026mdash;\u0026mdash;-+ | Column Name | Type | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-+\u0026mdash;\u0026mdash;\u0026mdash;-+ | id | int | | name | varchar | | sex | ENUM | | salary | int | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-+\u0026mdash;\u0026mdash;\u0026mdash;-+ id 是这个表的主键。 sex 这一列的值是 ENUM 类型，只能从 (\u0026rsquo;m\u0026rsquo;, \u0026lsquo;f\u0026rsquo;) 中取。 本表包含公司雇员的信息。 请你编写一个 SQL 查询来交换所有的 \u0026lsquo;f\u0026rsquo; 和 \u0026rsquo;m\u0026rsquo; （即，将所有 \u0026lsquo;f\u0026rsquo; 变为 \u0026rsquo;m\u0026rsquo; ，反之亦然），仅使用 单个 update 语句 ，且不产生中间临时表。\n注意，你必须仅使用一条 update 语句，且 不能 使用 select 语句。\n查询结果如下例所示。\n来源：力扣（LeetCode） 链接：https://leetcode.cn/problems/swap-salary 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n1 2 update salary set sex = char(ascii(\u0026#39;m\u0026#39;) + ascii(\u0026#39;f\u0026#39;) - ascii(sex)); -- 使用ascii码值的变换 sql语法特点 1 2 3 4 5 -- 方法一：MySql中的if语句 update salary set sex = if(sex = \u0026#39;m\u0026#39;, \u0026#39;f\u0026#39;, \u0026#39;m\u0026#39;) -- 方法二：case when语法 update salary set sex = case sex when \u0026#39;m\u0026#39; then \u0026#39;f\u0026#39; else \u0026#39;m\u0026#39; end; 03_delect_sql(建立两个表格) 输入: Person 表: +\u0026mdash;-+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;+ | id | email | +\u0026mdash;-+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;+ | 1 | john@example.com\r| | 2 | bob@example.com\r| | 3 | john@example.com\r| +\u0026mdash;-+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;+ 输出: +\u0026mdash;-+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;+ | id | email | +\u0026mdash;-+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;+ | 1 | john@example.com\r| | 2 | bob@example.com\r| +\u0026mdash;-+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;+ 解释: john@example.com\r重复两次。我们保留最小的Id = 1。\n来源：力扣（LeetCode） 链接：https://leetcode.cn/problems/delete-duplicate-emails 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n1 2 3 4 5 6 7 8 ## 删除重复项目 使用 sql自连接 ```sql DELETE p1 FROM Person p1, Person p2 WHERE p1.Email = p2.Email AND p1.Id \u0026gt; p2.Id ``` ","permalink":"https://www.jaywxl.eu.org/posts/study/02_stu/","summary":"01_找出出现一次的元素(reduce) 给你一个 非空 整数数组 nums ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元","title":"02_stu"},{"content":"01_03题 旋转 转置\n遍历\n栈存方法（学习）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 matrix = [[7,4],[9,5],[6,3]] nn = [] print(list(zip(*matrix))[::-1]) matrix = map(list, zip(*matrix)) print(matrix) i = 1 while matrix != []: if i%4 == 1: aa = matrix.pop(0) for a in range(len(aa)): nn.append(aa.pop(0)) if i%4 == 3: bb = matrix.pop(-1) for a in range(len(bb)): nn.append(bb.pop(-1)) if (i+1)%4 == 3: for a in range(len(matrix)): nn.append(matrix[a].pop(-1)) if (i+1)%4 == 1: for a in range(len(matrix))[::-1]: nn.append(matrix[a].pop(0)) i += 1 while [] in matrix: matrix.remove([]) print(nn) print(matrix) 1 2 3 sql 题目 只有 Ture False unknow 有NULL 要判断NULL ","permalink":"https://www.jaywxl.eu.org/posts/study/01_stu/","summary":"01_03题 旋转 转置 遍历 栈存方法（学习） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 matrix = [[7,4],[9,5],[6,3]] nn = [] print(list(zip(*matrix))[::-1]) matrix = map(list, zip(*matrix)) print(matrix) i = 1 while matrix != []:","title":"01_stu"},{"content":"","permalink":"https://www.jaywxl.eu.org/400/","summary":"400","title":"400"},{"content":"","permalink":"https://www.jaywxl.eu.org/50x/","summary":"50x","title":"50x"}]