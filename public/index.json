[{"content":" 在这里 向长安，对秋灯，几人老？\n这是一抔喧哗了千年的黄土，是十三朝顶礼膜拜的故都。这里秦时的明月正皎洁，汉代的城门正轻启。\n秦始皇在这里挥剑浮云，东指六国，逐鹿中原；汉武帝在这里横剑漠北，踏碎匈奴铁骑的狼烟；张骞在这里拜别故里，逶迤西行，踩出丝绸之路曲折的痕迹；玄奘在这里打点行装，把大唐盛世的种子播撒向繁花如锦的天竺。无数人怀揣着无数瑰丽的梦，把鲜活的生命化作丹砂，镌刻在汗青竹简里。这里，万世流芳。\n骊山的草木见证着，周幽烽火在这里戏取各路诸侯，褒姒倾国倾城的微笑揭开春秋乱世的序幕；大明宫殿前的麒麟目睹了，牡丹在这里不畏武皇淫威的铁骨铮铮，翩跹至洛阳而名动天下；华清池的海棠汤倒映过，杨贵妃在这里霓裳羽衣轻柔的魅影，断送一代盛世璀璨的华章；摆着酒座亭台楼阁回忆着，诗仙李白把酒当歌，绣口吐出半个盛唐的飘逸与洒脱。这是历史最绚丽的舞台，动人的故事演绎出一幕幕惊心动魄的诗行。这里，百转千回。\n响彻高原的秦腔伴着埙声叙述着悠远的传说，羊肉泡馍的暖汤融化了柿子上凝结的火红的秋霜。摇着蒲扇的老人，敲着波浪鼓的孩子，细嗅沿街槐花飘香十里，踏过梧桐橙黄橘绿的落叶缤纷；踩着高跟鞋的白领丽人，捂着耳机灌输摇滚的学生，穿过滚滚而过的车烟肆虐，抬眼望摩天大楼里映出的云淡风轻。精彩的生活，融入一个个或悠闲或匆忙的背影，传递着生命的脉搏，为世界注入鲜活的血液。这里，异彩纷呈。\n只有在这里，历史与现代才能如此完美地融合。如同古老的雁塔金铃声中飞扬的喷泉音乐，如同晨钟暮鼓的低吟浅唱里车流的喧嚣不息。\n这里，是时间的灰烬，是历史的尘埃，沐浴着新时代的甘露，绽放出一朵崭新的明媚的芬芳。\n这里，长安。\n","permalink":"https://bl.jawyxl.eu.org/posts/life/long_ago_compostion/","summary":"在这里 向长安，对秋灯，几人老？ 这是一抔喧哗了千年的黄土，是十三朝顶礼膜拜的故都。这里秦时的明月正皎洁，汉代的城门正轻启。 秦始皇在这里挥剑浮云","title":"Long_ago_compostion"},{"content":"缘起 第一次来汉中是在22年的八月份，那年夏天很热。炎炎的烈日烤干了我最后的暑期，滚烫的热浪就迫不及待地卷着我走入这纷杂的社会。\n刚进单位，在西安办完所有的手续，直接到汉中入职。 第一份工作主要是做传统的地质工作，搞搞边坡、削削坡、种种树，日子过得也算是快活。\n梦魇的到来，事情比心里的预期更加让人难以接受——干地质调查，每天从大山深处抡着双腿，用双脚丈量祖国大地。\n抚摸着葱葱郁郁的重峦叠嶂，聆听着清澈见底的曲水延绵。这是办公室同志们梦寐以求的工作。他们总说这像旅游一样。\n压弯的腰仍背负着生活，破旧的街道还承受着喧嚣。这是我感慨更深的生活。汗水播撒在土地，父子牵手于街巷，这是我爱的生活，纯粹的生活。（他们总会我人文摄影的欲火，我知道我是个腊鸡啦qaq-_-）\n100元人民币一层楼的住宿条件，满满当当的住着整个项目组。我辞职了，走的很决绝。\n人们总是说“找好下家，再辞职”、“想清楚了，再辞职”。我不喜欢，我想不清楚，我想不清不楚。\n回忆 23年的今天，下了D字头的动车，再一次来到这里，看着熟悉的街景，仿佛一切都没变，我也没变。我还是沉默害羞的，老同事们不敢再见了。以前会一个人悄悄地走在汉江漫滩；现在也是一个人悄悄地坐着吾悦广场的星巴克。\n景色不错欧，看着（应该是4号桥）景色，路的那头是南郑，记忆中，那边有很多别墅和奇哥老婆所在的龙岗中学。不知道两口的小宝宝生下来了吗？不知道峰哥儿子的吉他学的怎么样了？不知道龙哥和对象结婚了吗？不知道尚哥混出头了吗？哈哈哈\n人说工地上的人们总是情谊重的，确实，越艰辛的环境，越能凝结纯真的友谊。我喜欢，我想做一个纯粹的人。\n未知 生活：之前的吉他还学的不明不白，喜欢的up也断更了（她是去拥抱生活了我怎么办呢）。 家人：家里的老人走了，妈妈却不那么伤心，“对于一个不能进食的古稀老人，饿着、痛苦着躺了一个月了，这种结果也是一种解脱”妈妈是一个很好的人，她胆怯却不懦弱；她自我但却充满善良。她从来都是身体力行，充满力量与希望，她很纯粹，纯粹的让人总是可怜她烦的傻（要好好待家人，每年做个体检，担起责任）。 工作：领导受够了国企的掣肘，准备摆脱桎梏（我可能又要挪地方了）。 前路迷惘，一切未知；\n心怀热忱，披荆斩棘；\n永远怀着纯粹的少年心！\n","permalink":"https://bl.jawyxl.eu.org/posts/life/bcak_here_again/","summary":"故地重游，在人生的十字路口来到汉中，心里很是开心。这个地方还留存着步入社会的第一个脚印，今天走过了了旧人旧事老地方，交织着的回忆与现况，潸然泪下，以记此文","title":"故地重游_汉中行"},{"content":"聊一聊这段时间 前一段时间，一直在学习算法、数据库的相关知识，想着临门一脚，转型成功。 离职的这段时间，看了很多，看了很多自己，看了很多别人，浮躁，躺平，抖音\u0026hellip; 又回到了地质行业，我已经心如死灰^`^ 说点开心的吧：\n看了煤老板夺冠很开心，玩Xperia很开心，又好看的故事很开心 看到这位up很开心\n聊一聊题目的歌 这个翻唱up我很喜欢她的嗓音，温暖人心，解决了精神内耗，转行的失败，生活所谓的孤寂，人生价值的泯灭 她的歌声可以抚慰我心\n上一次的吉他学会了，就是弹唱对不上\nQAQ 前天去喝了酒，又聊到了高中的姑娘，我想起了高中的你 想起了2022初的错过\n","permalink":"https://bl.jawyxl.eu.org/posts/life/music_baozheni/","summary":"很久没写了，暂时搁置了转行的想法，回听起这首《抱着你》，提升不会放下，路也会沿着你的脚步想你铺来","title":"Music_抱着你"},{"content":"sql_Rank()函数 编写 SQL 查询对分数进行排序。排名按以下规则计算:\n分数应按从高到低排列。 如果两个分数相等，那么两个分数的排名应该相同。 在排名相同的分数后，排名数应该是下一个连续的整数。换句话说，排名之间不应该有空缺的数字。 按 score 降序返回结果表。\n查询结果格式如下所示。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 示例 1: 输入: Scores 表: +----+-------+ | id | score | +----+-------+ | 1 | 3.50 | | 2 | 3.65 | | 3 | 4.00 | | 4 | 3.85 | | 5 | 4.00 | | 6 | 3.65 | +----+-------+ 输出: +-------+------+ | score | rank | +-------+------+ | 4.00 | 1 | | 4.00 | 1 | | 3.85 | 2 | | 3.65 | 3 | | 3.65 | 3 | | 3.50 | 4 | +-------+------+ 来源：力扣（LeetCode）\n链接：https://leetcode.cn/problems/rank-scores\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\nrank\rrank()相关函数的使用\n1 2 3 4 5 6 7 8 9 # Write your MySQL query statement below select score, dense_rank() over (order by score desc) as \u0026#39;rank\u0026#39; #这个rank之所以要加引号，因为rank本身是个函数，直接写rank会报错 from scores; -- 异或这种count1前面的数据 select a.Score,(select count(distinct b.Score) from Scores b where b.Score \u0026gt;= a.Score) as \u0026#39;rank\u0026#39; from Scores a order by a.Score DESC; ","permalink":"https://bl.jawyxl.eu.org/posts/study/15_stu/","summary":"","title":"15_stu"},{"content":"数组之求和为k的连续子数组数量 给你一个整数数组 nums 和一个整数 k ，请你统计并返回 该数组中和为 k 的连续子数组的个数 。\n示例 1：\n输入：nums = [1,1,1], k = 2 输出：2\n示例 2：\n输入：nums = [1,2,3], k = 3 输出：2\n来源：力扣（LeetCode）\n链接：https://leetcode.cn/problems/subarray-sum-equals-k\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n使用的原理就是 presum-k 若在 之前哈希表中的 presum 出现过 那么 必定有连续的数组和为k\n因为之前统计的presum为一段连续数组，现如今的presum同为连续数组，两个连续数组相减，和为k的数组也必为连续数组\n若presum在哈希表中不唯一 表示连续数组中出现了和为0的子数组。\n111\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution: def subarraySum(self, nums: List[int], k: int) -\u0026gt; int: prehash = dict() prehash[0] = 1 preSum = 0 count = 0 for num in nums: preSum += num if preSum - k in prehash: count += prehash[preSum - k] if preSum not in prehash: prehash[preSum] = 1 else: prehash[preSum] += 1 return count ","permalink":"https://bl.jawyxl.eu.org/posts/study/14_stu/","summary":"","title":"14_stu"},{"content":" 关于张悬_我想你要走了\nPart1_缘起时 最近很喜欢的一位UP主，长相美丽舒适，声音温暖治愈。\n对于人生十字路口的我给予了很多的温暖与慰藉\n很高兴在这个世界、在这段时间遇上这么美丽的一位UP。\n是的，在这个无人问津的角落\n记录一下，我的荣幸与喜欢吧！🤣\nPart2_情丝绕 hahah，有没有想起琅琊榜呢，这可真是太棒了呢 去找了张悬这首歌的 吉他谱\n顺嘴吐槽一下，我这吉他学的是真差劲，四月有余，和弦都按不明白\n最终在这个网站找到了吉他谱(GO Here)👉\r吉他谱\rPart3_ 还没想好起什么名字\n当然是我自己的弹唱啦\n","permalink":"https://bl.jawyxl.eu.org/posts/life/music_miaomiao/","summary":"","title":"Music_我想你要走了"},{"content":"写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target 。该矩阵具有以下特性：\n每行的元素从左到右升序排列。\n每列的元素从上到下升序排列。 img\r来源：力扣（LeetCode）\n链接：https://leetcode.cn/problems/search-a-2d-matrix-ii\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 \u0026#34;\u0026#34;\u0026#34; * 二分法 * z字型搜索 从右上角 两个边界数值 一大一小的地方 开启搜索 各向异性 \u0026#34;\u0026#34;\u0026#34; Method_二分法 class Solution: def searchMatrix(self, matrix: List[List[int]], target: int) -\u0026gt; bool: for row in matrix: idx = bisect.bisect_left(row, target) if idx \u0026lt; len(row) and row[idx] == target: return True return False Method_z字型法则 \u0026#34;\u0026#34;\u0026#34; 从右上角 或 左下角 开始搜索 满足两个方向的不同 \u0026#34;\u0026#34;\u0026#34; class Solution: def searchMatrix(self, matrix: List[List[int]], target: int) -\u0026gt; bool: m, n = len(matrix), len(matrix[0]) x, y = 0, n - 1 while x \u0026lt; m and y \u0026gt;= 0: if matrix[x][y] == target: return True if matrix[x][y] \u0026gt; target: y -= 1 else: x += 1 return False ","permalink":"https://bl.jawyxl.eu.org/posts/study/13_stu/","summary":"","title":"13_stu"},{"content":"01_二叉搜索树公共祖先 给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。\n百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”\n例如，给定如下二叉搜索树: root = [6,2,8,0,4,7,9,null,null,3,5]\n公共祖先\r示例 1:\n输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8 输出: 6 解释: 节点 2 和节点 8 的最近公共祖先是 6。\n来源：力扣（LeetCode） 链接：https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None \u0026#34;\u0026#34;\u0026#34; 巧妙的运用了二叉树搜索的条件定义，左中右三个值的大小关系 \u0026#34;\u0026#34;\u0026#34; class Solution: def lowestCommonAncestor(self, root: \u0026#39;TreeNode\u0026#39;, p: \u0026#39;TreeNode\u0026#39;, q: \u0026#39;TreeNode\u0026#39;) -\u0026gt; \u0026#39;TreeNode\u0026#39;: small,big=(p,q) if p.val\u0026lt;q.val else (q,p) if small.val\u0026lt;=root.val: if big.val\u0026gt;=root.val: return root else: return self.lowestCommonAncestor(root.left,p,q) else: return self.lowestCommonAncestor(root.right,p,q) ","permalink":"https://bl.jawyxl.eu.org/posts/study/12_stu/","summary":"","title":"12_stu"},{"content":"\rTarget\rsee 动态规划 init github\u0026quot;stock_trade\u0026quot; and ReadMe 02_路径总和 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right # class Solution: # def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -\u0026gt; bool: # if root: # targetSum = targetSum - root.val # else: # return False # stack = [] # sum = [] # while root: # print(root) # a,b = float(\u0026#39;-inf\u0026#39;),float(\u0026#39;-inf\u0026#39;) # if root.left: a = root.left.val # if root.right: b = root.right.val # if root.right and root.left: # stack.append(root) # sum.append(targetSum) # if a \u0026gt; b : # targetSum -= a # root = root.left # else: # targetSum -= b # root = root.right # print(root) # if targetSum != 0 and not root.left and not root.right and stack: # root = stack.pop() # targetSum = sum.pop() # if root.right.val \u0026gt; root.left.val: # root.right = None # else: # root.left = None # elif targetSum == 0 and not root.left and not root.right: # return True # elif targetSum != 0 and not root.left and not root.right: # return False \u0026#34;\u0026#34;\u0026#34; 最终被击溃在两个子节点数值相等的问题上导致无法回溯，可以优化存在栈里面回溯的treenode，将选择的一边设为None \u0026#34;\u0026#34;\u0026#34; Method_递归 class Solution(object): def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -\u0026gt; bool: if not root: return False if not root.left and not root.right: return targetSum == root.val return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val) 02_搜索二叉树 搜索二叉树满足对于任意节点 root 而言，左子树（如果存在）上所有节点的值均小于 \\textit{root.val}root.val，右子树（如果存在）上所有节点的值均大于 \\textit{root.val}root.val，且它们都是二叉搜索树。 递归\ninit_stock_trade","permalink":"https://bl.jawyxl.eu.org/posts/study/11_stu/","summary":"","title":"11_stu"},{"content":"二叉树 img\r最重点的内容就是：不管是先序中序还是后序，查找流程都是从上到下，先左后右。只是输出的时机不同。\n先序就是发现了先输出，再先左后右。\n中序就是发现了先存着，当左边遍历完了，再把存着的输出出来。\n后序就是发现了先存着，当左边和右边都遍历完了，再把存着的输出出来。\n01_二叉树前序 Method:迭代\n1 2 3 4 5 6 7 8 9 10 11 class Solution: def preorderTraversal(self, root: TreeNode) -\u0026gt; List[int]: if not root: return [] stack = [root] res = [] while stack : p = stack.pop() res.append(p.val) if p.right: stack.append(p.right) if p.left: stack.append(p.left) return res 02_二叉树中序 Method:递归\n1 2 3 4 5 6 7 8 9 10 11 class Solution: def inorderTraversal(self, root: Optional[TreeNode]) -\u0026gt; List[int]: res=list() def midorder(root:TreeNode): if not root: return midorder(root.left) res.append(root.val) midorder(root.right) midorder(root) return res 03_二叉树后序 Method:迭代\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution: def postorderTraversal(self, root: Optional[TreeNode]) -\u0026gt; List[int]: res=[] if not root: return res node=root stack=[] while stack or node: while node: res.append(node.val) stack.append(node) node=node.right node=stack.pop() node=node.left return res[::-1] ","permalink":"https://bl.jawyxl.eu.org/posts/study/10_stu/","summary":"","title":"10_stu"},{"content":"01_栈_哈希表_有效括号 给定一个只包括 \u0026lsquo;(\u0026rsquo;，\u0026rsquo;)\u0026rsquo;，\u0026rsquo;{\u0026rsquo;，\u0026rsquo;}\u0026rsquo;，\u0026rsquo;[\u0026rsquo;，\u0026rsquo;]\u0026rsquo; 的字符串 s ，判断字符串是否有效。\n有效字符串需满足：\n左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 每个右括号都有一个对应的相同类型的左括号。 示例 1：\n输入：s = \u0026ldquo;()\u0026rdquo; 输出：true\n示例 2：\n输入：s = \u0026ldquo;()[]{}\u0026rdquo; 输出：true\n示例 3：\n输入：s = \u0026ldquo;(]\u0026rdquo; 输出：false\n来源：力扣（LeetCode） 链接：https://leetcode.cn/problems/valid-parentheses 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 栈的思想\r{([])} 利用先进后出的原则来判断括号是否闭合\n每个stack的-1位置需要和dic字典里的键值对相互对应\n1 2 3 4 5 6 7 8 9 10 11 12 class Solution: def isValid(self, s: str) -\u0026gt; bool: dic = {\u0026#39;)\u0026#39;:\u0026#39;(\u0026#39;,\u0026#39;]\u0026#39;:\u0026#39;[\u0026#39;,\u0026#39;}\u0026#39;:\u0026#39;{\u0026#39;} stack = [] for i in s: if stack and i in dic: if stack[-1] == dic[i]: stack.pop() else: return False else: stack.append(i) return not stack ","permalink":"https://bl.jawyxl.eu.org/posts/study/08_09_stu/","summary":"","title":"08_09_stu"},{"content":"1_链表_判断是否有环 开启链表的学习主要是快慢指针方法 或者 用哈希表的方法 leecode_链表\r输入：head = [3,2,0,-4], pos = 1 输出：true 解释：链表中有一个环，其尾部连接到第二个节点。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 # Definition for singly-linked list. # class ListNode: # def __init__(self, x): # self.val = x # self.next = None class Solution: def hasCycle(self, head: ListNode) -\u0026gt; bool: # 空链表或链表只有一个节点，无环 if not head or head.next == None: return False # 初始化快慢指针 fast = slow = head # 如果不存在环，肯定 fast 先指向 null # 细节：fast 每次走 2 步，所以要确定 fast 和 fast.next 不为空，不然会报执行出错。 while fast and fast.next: # 快指针移动 2 步，慢指针移动 1 步 fast = fast.next.next slow = slow.next # 快慢指针相遇，有环 if fast == slow: return True return 2_链表递归 给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。 示例 1： 2\r输入：head = [1,2,6,3,4,5,6], val = 6 输出：[1,2,3,4,5] 示例 2：\n输入：head = [], val = 1 输出：[] 示例 3：\n输入：head = [7,7,7,7], val = 7 输出：[]\n来源：力扣（LeetCode） 链接：https://leetcode.cn/problems/remove-linked-list-elements 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n1 2 3 4 5 6 7 8 9 10 11 12 class Solution: def removeElements(self, head: Optional[ListNode], val: int) -\u0026gt; Optional[ListNode]: if not head: return head if head.val == val : head = self.removeElements(head.next,val) return head else: # self.removeElements(head.next,val) 错误是否需要前面先赋值，否则return的怎么返回 eg下方正确方式 head.next = self.removeElements(head.next,val) return head ","permalink":"https://bl.jawyxl.eu.org/posts/study/07_stu/","summary":"","title":"07_stu"},{"content":"01_adddate 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 输入： Weather 表： +----+------------+-------------+ | id | recordDate | Temperature | +----+------------+-------------+ | 1 | 2015-01-01 | 10 | | 2 | 2015-01-02 | 25 | | 3 | 2015-01-03 | 20 | | 4 | 2015-01-04 | 30 | +----+------------+-------------+ 输出： +----+ | id | +----+ | 2 | | 4 | +----+ 解释： 2015-01-02 的温度比前一天高（10 -\u0026gt; 25） 2015-01-04 的温度比前一天高（20 -\u0026gt; 30） 来源：力扣（LeetCode） 链接：https://leetcode.cn/problems/rising-temperature 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 1 2 3 4 5 -- ADDDATE函数日期增加 -- inner join内连接 会删除没有匹配的项 不会保留null SELECT id from Weather w1 left join (SELECT ADDDATE(recordDate,1) as uid,Temperature as t from Weather)w2 on w1.recordDate = w2.uid WHERE Temperature \u0026gt; t; 02_判断两个字符串中元素是否一样多 1 2 3 4 5 6 7 8 9 10 import collections s = \u0026#34;ab\u0026#34; t = \u0026#34;ba\u0026#34; class Solution: def firstUniqChar( s: str, t: str) -\u0026gt; bool: # print(sorted(collections.Counter(t).most_common())) # print(collections.Counter(t).most_common()) sorted()排序 return sorted(collections.Counter(s).most_common()) == sorted(collections.Counter(t).most_common()) print(Solution.firstUniqChar(s,t)) ","permalink":"https://bl.jawyxl.eu.org/posts/study/06_stu/","summary":"01_adddate 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 输入： Weather 表： +----+------------+-------------+ | id | recordDate | Temperature | +----+------------+-------------+ | 1 | 2015-01-01 | 10 | | 2 | 2015-01-02 | 25 | | 3 | 2015-01-03 | 20 | | 4 | 2015-01-04 | 30 | +----+------------+-------------+ 输","title":"06_stu"},{"content":"01_sql 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 给定一个表 tree，id 是树节点的编号， p_id 是它父节点的 id 。 +----+------+ | id | p_id | +----+------+ | 1 | null | | 2 | 1 | | 3 | 1 | | 4 | 2 | | 5 | 2 | +----+------+ 树中每个节点属于以下三种类型之一： 叶子：如果这个节点没有任何孩子节点。 根：如果这个节点是整棵树的根，即没有父节点。 内部节点：如果这个节点既不是叶子节点也不是根节点。 写一个查询语句，输出所有节点的编号和节点的类型，并将结果按照节点编号排序。上面样例的结果为： +----+------+ | id | Type | +----+------+ | 1 | Root | | 2 | Inner| | 3 | Leaf | | 4 | Leaf | | 5 | Leaf | +----+------+ 来源：力扣（LeetCode） 链接：https://leetcode.cn/problems/tree-node 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 -- case when Method select id, case when p_id is NULL then \u0026#39;Root\u0026#39; when id in ( select atree.p_id from tree as atree ) then \u0026#39;Inner\u0026#39; else \u0026#39;Leaf\u0026#39; end as type from tree -- if else Method SELECT id, IF(p_id IS NULL, \u0026#39;Root\u0026#39;, IF(id IN ( SELECT DISTINCT p_id FROM tree WHERE p_id IS NOT NULL ),\u0026#39;Inner\u0026#39;,\u0026#39;Leaf\u0026#39;) ) AS Type FROM tree 02_limit_offset_sql 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 Employee 表： +-------------+------+ | Column Name | Type | +-------------+------+ | id | int | | salary | int | +-------------+------+ id 是这个表的主键。 表的每一行包含员工的工资信息。 编写一个 SQL 查询，获取并返回 Employee 表中第二高的薪水 。如果不存在第二高的薪水，查询应该返回 null 。 查询结果如下例所示。 示例 1： 输入： Employee 表： +----+--------+ | id | salary | +----+--------+ | 1 | 100 | | 2 | 200 | | 3 | 300 | +----+--------+ 输出： +---------------------+ | SecondHighestSalary | +---------------------+ | 200 | +---------------------+ 来源：力扣（LeetCode） 链接：https://leetcode.cn/problems/second-highest-salary 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 1 2 3 4 5 6 7 8 9 -- LIMIT 返回一步 OFFSET 跳过一步 DESC 倒序排列 SELECT (SELECT DISTINCT Salary FROM Employee ORDER BY Salary DESC LIMIT 1 OFFSET 1) AS SecondHighestSalary ; 03_数独游戏 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 def isValidSudoku(): board = [[\u0026#34;8\u0026#34;,\u0026#34;3\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;7\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;] ,[\u0026#34;6\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;9\u0026#34;,\u0026#34;5\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;] ,[\u0026#34;.\u0026#34;,\u0026#34;9\u0026#34;,\u0026#34;8\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;6\u0026#34;,\u0026#34;.\u0026#34;] ,[\u0026#34;8\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;6\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;3\u0026#34;] ,[\u0026#34;4\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;8\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;3\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;1\u0026#34;] ,[\u0026#34;7\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;2\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;6\u0026#34;] ,[\u0026#34;.\u0026#34;,\u0026#34;6\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;2\u0026#34;,\u0026#34;8\u0026#34;,\u0026#34;.\u0026#34;] ,[\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;4\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;9\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;5\u0026#34;] ,[\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;8\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;7\u0026#34;,\u0026#34;9\u0026#34;]] \u0026#39;\u0026#39;\u0026#39; 哈希算法 row,col,block分别生成的依据是9行*9个数字、9列*9个数字、9块*9个数字 在判断相同行列块中数字是否变成了赋值的1 从而return 不能 使用 [[0] *9]*9 这样第二个九相当于引用了9遍列表[[0] * 9] 会出现修改后数值都变 exp: [[1,0,0,0],[1,0,0,0],[1,0,0,0],[1,0,0,0]] \u0026#39;\u0026#39;\u0026#39; row = [[0] * 9 for _ in range(9)] col = [[0] * 9 for _ in range(9)] block = [[0] * 9 for _ in range(9)] for i in range(9): for j in range(9): if board[i][j] != \u0026#39;.\u0026#39;: num = int(board[i][j]) - 1 print(num) b = (i // 3) * 3 + j // 3 print(b) if row[i][num] or col[j][num] or block[b][num]: print(block) return False row[i][num] = col[j][num] = block[b][num] = 1 return True \u0026#39;\u0026#39;\u0026#39; Method 2 ： 生成三种数组，再将合并成一种数组，遍历其中的counter，看每个的计数情况是否为 0，1 改进 判断哈希赋值 32ms,99% \u0026#39;\u0026#39;\u0026#39; # n = list(map(list,zip(*board))) # nn,nnn = [],[] # for a in board: # nn += a # ab = [nn[i:i+3] for i in range(0,len(nn),3)] # for b in [0,1,2,9,10,11,18,19,20]: # nnn += [ab[b]+ab[b+3]+ab[b+6]] # num = board+n+nnn for i in num: nnnn = [0]*9 for a in i: if a != \u0026#39;.\u0026#39;: n = int(a) - 1 if nnnn[n] == 1: return False nnnn[n] = 1 return True # rs = 0 # for a in range(len(num)): # count = Counter(num[a]) # for i in range(1,10): # if count[str(i)] not in [0,1]: # rs += 1 # return False # else: continue # if rs == 0 : return True ","permalink":"https://bl.jawyxl.eu.org/posts/study/05_stu/","summary":"01_sql 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 给定一个表 tree，id 是树节点的编号， p_id 是它父节点的 id 。 +----+------+ | id | p_id | +----+------+ |","title":"05_stu"},{"content":"01_数组切片分组 1 2 3 4 5 6 7 8 9 10 11 12 mat = [[1,2],[3,4],[5,6]] r,c = 2,3 ans = [[0]*c for _ in range(r)] a = [] class Solution: def matrixReshape(self, mat: List[List[int]], r: int, c: int) -\u0026gt; List[List[int]]: if len(mat)*len(mat[0]) == r*c : for i in mat: a +=i return [a[i:i + c] for i in range(0, len(a), c)] else: return mat 02_杨辉三角 杨辉三角\n弄清yieid 和 return 区别 yieid可迭代\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution: def triangles(b): L = [1] i = 0 #定义L为一个只包含一个元素的列表 while i \u0026lt; b: i += 1 yield L #定义为生成器函数 L =[1] + [L[n] + L[n-1] for n in range(1,len(L))] + [1] def generate(self, numRows: int) -\u0026gt; list[list[int]]: n = [] for a in Solution.triangles(numRows): print(a) n.append(a) return n # 方法二 简化 L = [1] i = 0 #定义L为一个只包含一个元素的列表 n = [] while i \u0026lt; b: i += 1 n.append(L) L =[1] + [L[n] + L[n-1] for n in range(1,len(L))] + [1] return n ","permalink":"https://bl.jawyxl.eu.org/posts/study/04_stu/","summary":"01_数组切片分组 1 2 3 4 5 6 7 8 9 10 11 12 mat = [[1,2],[3,4],[5,6]] r,c = 2,3 ans = [[0]*c for _ in range(r)] a = [] class Solution: def matrixReshape(self, mat: List[List[int]], r: int, c: int) -\u0026gt; List[List[int]]: if len(mat)*len(mat[0]) == r*c : for i in mat: a +=i return [a[i:i + c] for i in range(0, len(a), c)]","title":"04_stu"},{"content":"01_返回交集 给你两个整数数组 nums1 和 nums2 ，请你以数组形式返回两数组的交集。返回结果中每个元素出现的次数，应与元素在两个数组中都出现的次数一致（如果出现次数不一致，则考虑取较小值）。可以不考虑输出结果的顺序。 示例 1：\n输入：nums1 = [1,2,2,1], nums2 = [2,2] 输出：[2,2] 示例 2:\n输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4] 输出：[4,9]\n来源：力扣（LeetCode） 链接：https://leetcode.cn/problems/intersection-of-two-arrays-ii 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from collections import Counter import collections nums1 = [1,2,1,3] nums2 = [2,2,3] nn = [] n = 1 count = Counter(nums1) print(count[4]) ans = [] for num in nums2: if count[num] != 0: print(count) ans.append(num) count[num] -= 1 print(ans) c = (collections.Counter(nums1)\u0026amp;collections.Counter(nums2)).elements() # 一行代码 print(c) d = nums1\u0026amp;nums2 print(d) 02_concat_upper_lower_sql 1 2 3 4 5 6 CONCAT # 拼接字符串 LEFT,RIGHT UPPER,LOWER # 大写，小写 select user_id, CONCAT(UPPER(left(name, 1)), LOWER(RIGHT(name, length(name) - 1))) as name from Users order by user_id; 03_sql 1 2 3 4 5 6 7 -- group_concat 字符串连接 -- group by 分组 -- count 统计 -- distinct 去重 select sell_date, count(distinct(product)) as num_sold, group_concat(distinct product order by product asc separator \u0026#39;,\u0026#39;) as products from Activities group by sell_date; 04_sql 1 2 3 4 select patient_id,patient_name,conditions from PAtients where conditions regexp \u0026#39;^DIAB1|\\\\sDIAB1\u0026#39;; # 正则表达式 where conditions like \u0026#39;DIAB1%\u0026#39; or conditions like \u0026#39;% DIAB1%\u0026#39; #like的匹配得有百分号（类似于*） 否则该语句等同于= ","permalink":"https://bl.jawyxl.eu.org/posts/study/03_stu/","summary":"01_返回交集 给你两个整数数组 nums1 和 nums2 ，请你以数组形式返回两数组的交集。返回结果中每个元素出现的次数，应与元素在两个数组中都出现的次数一致（如","title":"03_stu"},{"content":"01_找出出现一次的元素(reduce) 给你一个 非空 整数数组 nums ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。\n你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。\n来源：力扣（LeetCode）\n链接：https://leetcode.cn/problems/single-number\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\nreduce函数累计 a^b^c^d^\u0026hellip;.\n异或 不同输出本身 时间复杂度O(1) 空间复杂度O(n)\n1 2 3 4 5 6 7 from functools import reduce nums = [1,2,3,4,4,3,2] class Solution: def singleNumber(nums: list[int]) -\u0026gt; int: return reduce(lambda x,y : x^y,nums) print(Solution.singleNumber(nums)) 02_update_sql方法(ascii,if方法,case when) Salary 表：\n+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-+\u0026mdash;\u0026mdash;\u0026mdash;-+ | Column Name | Type | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-+\u0026mdash;\u0026mdash;\u0026mdash;-+ | id | int | | name | varchar | | sex | ENUM | | salary | int | +\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-+\u0026mdash;\u0026mdash;\u0026mdash;-+ id 是这个表的主键。 sex 这一列的值是 ENUM 类型，只能从 (\u0026rsquo;m\u0026rsquo;, \u0026lsquo;f\u0026rsquo;) 中取。 本表包含公司雇员的信息。 请你编写一个 SQL 查询来交换所有的 \u0026lsquo;f\u0026rsquo; 和 \u0026rsquo;m\u0026rsquo; （即，将所有 \u0026lsquo;f\u0026rsquo; 变为 \u0026rsquo;m\u0026rsquo; ，反之亦然），仅使用 单个 update 语句 ，且不产生中间临时表。\n注意，你必须仅使用一条 update 语句，且 不能 使用 select 语句。\n查询结果如下例所示。\n来源：力扣（LeetCode） 链接：https://leetcode.cn/problems/swap-salary 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n1 2 update salary set sex = char(ascii(\u0026#39;m\u0026#39;) + ascii(\u0026#39;f\u0026#39;) - ascii(sex)); -- 使用ascii码值的变换 sql语法特点 1 2 3 4 5 -- 方法一：MySql中的if语句 update salary set sex = if(sex = \u0026#39;m\u0026#39;, \u0026#39;f\u0026#39;, \u0026#39;m\u0026#39;) -- 方法二：case when语法 update salary set sex = case sex when \u0026#39;m\u0026#39; then \u0026#39;f\u0026#39; else \u0026#39;m\u0026#39; end; 03_delect_sql(建立两个表格) 输入: Person 表: +\u0026mdash;-+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;+ | id | email | +\u0026mdash;-+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;+ | 1 | john@example.com\r| | 2 | bob@example.com\r| | 3 | john@example.com\r| +\u0026mdash;-+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;+ 输出: +\u0026mdash;-+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;+ | id | email | +\u0026mdash;-+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;+ | 1 | john@example.com\r| | 2 | bob@example.com\r| +\u0026mdash;-+\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;+ 解释: john@example.com\r重复两次。我们保留最小的Id = 1。\n来源：力扣（LeetCode） 链接：https://leetcode.cn/problems/delete-duplicate-emails 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n1 2 3 4 5 6 7 8 ## 删除重复项目 使用 sql自连接 ```sql DELETE p1 FROM Person p1, Person p2 WHERE p1.Email = p2.Email AND p1.Id \u0026gt; p2.Id ``` \u0026lt;!-- ","permalink":"https://bl.jawyxl.eu.org/posts/study/02_stu/","summary":"01_找出出现一次的元素(reduce) 给你一个 非空 整数数组 nums ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元","title":"02_stu"},{"content":"01_03题 旋转 转置\n遍历\n栈存方法（学习）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 matrix = [[7,4],[9,5],[6,3]] nn = [] print(list(zip(*matrix))[::-1]) matrix = map(list, zip(*matrix)) print(matrix) i = 1 while matrix != []: if i%4 == 1: aa = matrix.pop(0) for a in range(len(aa)): nn.append(aa.pop(0)) if i%4 == 3: bb = matrix.pop(-1) for a in range(len(bb)): nn.append(bb.pop(-1)) if (i+1)%4 == 3: for a in range(len(matrix)): nn.append(matrix[a].pop(-1)) if (i+1)%4 == 1: for a in range(len(matrix))[::-1]: nn.append(matrix[a].pop(0)) i += 1 while [] in matrix: matrix.remove([]) print(nn) print(matrix) 1 2 3 sql 题目 只有 Ture False unknow 有NULL 要判断NULL ","permalink":"https://bl.jawyxl.eu.org/posts/study/01_stu/","summary":"01_03题 旋转 转置 遍历 栈存方法（学习） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 matrix = [[7,4],[9,5],[6,3]] nn = [] print(list(zip(*matrix))[::-1]) matrix = map(list, zip(*matrix)) print(matrix) i = 1 while matrix != []:","title":"01_stu"},{"content":"时光笔记_1 生活小感慨 快乐的时光总是短暂的，进入了社会的小同志才知道学校的美好时光。那无忧无虑，那轻松惬意，那青春气息。\n美好小回忆 想起的都是美好的点点滴滴，当然是和男人的，男人在一起总是快乐的，一点小事，鸡毛蒜皮，相互阴阳怪气，相互恶心不已，确实那么的无法自拔，有人作陪那是极好的。\n未来小展望 进入了工作当中，姜文说，谁会把秘密写到日记中去呀。（PS：有点想念上学看一步之遥的日子了），人在看的似懂非懂的时候是最装B的，就是不管生活之中遇到了什么情况，都得和差一步，一步之遥搭上关系。诶呀，又想歪了。前一阵儿，认识了个姑娘，当时喝多了晚上，唱歌认识的，就聊，硬聊。第二天，干什么都变得不一样了，和哥们打游戏都感觉变猛了。姑娘说：你是不是今天做的所有的事情都得和我搭上关系（呼应）。深思呀~~~，人是贱的，可能我是，总是把自己所期望的，变成所期望的，从而让自己认同期望的，太一厢情愿了，尤其是小男生，所以，才有了人生三大幻觉，所以，谨此告诫各位小男生，放弃幻想，认清现实，不要感动自我，更不要你以为。（哦又差题了）\n聊未来，小弟进入了一家正在改制的事业单位，虽说也是央企，可学地质的进这种不是宛如喝凉水一般，我是不幸的，也是幸运的，作为49年入国军的我，在工作之中遇到这么多趣人趣事，最开心的莫过于，斗争就在你眼前。我发现现在的人都冲浪的很喜欢吃瓜，虽然与我无瓜，但他就是要吃一口。嗯，大戏就在我眼前，我终于体会到前排VIP的观感了，精彩，精彩绝伦。\n听单位的前辈哥哥们说，他们看到我，就看到了十年前的自己，嗯，说不好，说不准未来如何，但我不求出彩，尽力精彩。\n引用人民日报的一句话，做时代的弄潮儿，勇立潮头。\n都说秘密不会写在日记里 -Jw 2022.09.19 21:14\r","permalink":"https://bl.jawyxl.eu.org/posts/life/firth/","summary":"时光笔记_1 生活小感慨 快乐的时光总是短暂的，进入了社会的小同志才知道学校的美好时光。那无忧无虑，那轻松惬意，那青春气息。 美好小回忆 想起的都是","title":"Firth"},{"content":" miniapp 原网站jt.jaywxl.asia\r,因为校园保卫人员职业素养的提升，网站形成的假条已经被废弃。\n现在已经将假条项目迁移至小程序。\n可以微信搜索Jaywxl jpg\r本项目所有源码都在GitHub开源(ps:后端还未完成push) 感谢各位校友的支持，请勿外传，有更好css想法的朋友，可以在下方评论！😘\n","permalink":"https://bl.jawyxl.eu.org/posts/life/miniapp/","summary":"miniapp 原网站jt.jaywxl.asia ,因为校园保卫人员职业素养的提升，网站形成的假条已经被废弃。 现在已经将假条项目迁移至小程序。 可以微信搜索","title":"Miniapp"},{"content":"xust实现全自动打卡 这是个令人激动的时刻对于我们来说\n这个项目让我们告别了每天繁琐的五点打卡\n导员的催促、班委的通知\n却也还是总让我们忘记，从而得到导员温柔的问候\n接下来开始正体 所需软体和条件\n一个可以手机抓包的软件(ps:还没看pc版的西科e站包在哪里，后续可能回更新) 你需要你个登录了西科e站的微信app 需要一个富强的环境(ps:当然GitHub也可以不，会很慢🤣🤣) 1.首先打开抓包软体,找到如下图所示的包 获uid! uidpc\ruid1\ruid2\r2.电脑登入西科e站,f12,点打卡提交后,找到如下的包,获得最下边的payload! payload\r3.有了上边两个步骤之后,访问我的项目地址,并且fork我的仓库Checkin\r,并替换python文件里的uid,payload,自此今后的打卡就会上传你payload的信息! GitHub\rps:当然你可以替换文件里的sckey,从此获得消息推送,如出现{}字符,即为打卡成功\n感谢你的观看❤😁 ","permalink":"https://bl.jawyxl.eu.org/posts/life/third/","summary":"xust实现全自动打卡 这是个令人激动的时刻对于我们来说 这个项目让我们告别了每天繁琐的五点打卡 导员的催促、班委的通知 却也还是总让我们忘记，从而","title":"XUST 自动打卡"},{"content":"影视收藏 😜🤥\n不定期更新\n所有站点都来源于互联网\n低端影视\r哔嘀影视\r真不卡 片库\r独播库\r奈飞中文电影站\r泥巴影院\rTubitv\r剧嗨\r一些种子站点\n--by Jaywxl\n","permalink":"https://bl.jawyxl.eu.org/posts/life/secend/","summary":"影视收藏 😜🤥 不定期更新 所有站点都来源于互联网 低端影视 哔嘀影视 真不卡 片库 独播库 奈飞中文电影站 泥巴影院 Tubitv 剧嗨 一些种子站点 --by Jaywxl","title":"影视收藏"},{"content":"我的博客又要开始了 今后我会在vscode 来写markdown来更新我的blog 希望可以帮助到各位！！！😁\n","permalink":"https://bl.jawyxl.eu.org/posts/life/first-post/","summary":"我的博客又要开始了 今后我会在vscode 来写markdown来更新我的blog 希望可以帮助到各位！！！😁","title":"First Post"},{"content":"","permalink":"https://bl.jawyxl.eu.org/400/","summary":"400","title":"400"},{"content":"","permalink":"https://bl.jawyxl.eu.org/50x/","summary":"50x","title":"50x"}]